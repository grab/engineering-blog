<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Grab Tech</title>
    <description>Grab&apos;s Engineering team solves critical transportation challenges and makes transport freedom a reality for 620 million people in Southeast Asia.
</description>
    <link>https://engineering.grab.com/</link>
    <atom:link href="https://engineering.grab.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 03 May 2024 10:10:00 +0000</pubDate>
    <lastBuildDate>Fri, 03 May 2024 10:10:00 +0000</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>No version left behind: Our epic journey of GitLab upgrades</title>
        <description>&lt;p&gt;In a tech-driven field, staying updated isn’t an option—it’s essential. At Grab, we’re committed to providing top-notch technology services. However, keeping pace can be demanding. At one point in time, our GitLab instance was trailing by roughly 14 months of releases. This blog post recounts our experience updating and formulating a consistent upgrade routine.&lt;/p&gt;

&lt;h2 id=&quot;recognising-the-need-to-upgrade&quot;&gt;Recognising the need to upgrade&lt;/h2&gt;

&lt;p&gt;Our team, while skilled, was still learning GitLab’s complexities. Regular stability issues left us little time for necessary upgrades. Understanding the importance of upgrades for our operations to get latest patches for important security fixes and vulnerabilities, we started preparing for GitLab updates while managing system stability. This meant a quick learning and careful approach to updates.&lt;/p&gt;

&lt;p&gt;The following image illustrates the version discrepancy between our self-hosted GitLab instance and the official most recent release of GitLab as of July 2022. GitLab follows a set &lt;a href=&quot;https://about.gitlab.com/releases&quot;&gt;release schedule&lt;/a&gt;, issuing one minor update monthly and rolling out a major upgrade annually.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/no-version-left-behind-our-epic-journey-of-gitlab-upgrades/version-diff.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig 1. The difference between our hosted version and the latest available GitLab version by 22 July 2022&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;h2 id=&quot;addressingfears-and-concerns&quot;&gt;Addressing fears and concerns&lt;/h2&gt;

&lt;p&gt;We were concerned about potential downtime, data integrity, and the threat of encountering unforeseen issues. GitLab is critical for the daily activities of Grab engineers. It serves a critical user base of thousands of engineers actively using it, hosting multiple mono repositories with code bases ranging in size from 1GB to a sizable &lt;strong&gt;15GB&lt;/strong&gt;. When taking into account all its artefacts, the overall imprint of a monorepo can extend to an impressive &lt;strong&gt;39TB&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Our self-hosted GitLab firmly intertwines with multiple critical components. We’ve aligned our systems with GitLab’s official &lt;a href=&quot;https://docs.gitlab.com/ee/administration/reference_architectures/5k_users.html&quot;&gt;reference architecture for 5,000 users&lt;/a&gt;. We use Terraform to configure complete infrastructure with immutable Amazon Machine Images (&lt;a href=&quot;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html&quot;&gt;AMIs&lt;/a&gt;) built using Packer and Ansible. Our efficient GitLab setup is designed for reliable performance to serve our wide user base. However, any fault leading to outages can disrupt our engineers, resulting in a loss of productivity for hundreds of teams.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/no-version-left-behind-our-epic-journey-of-gitlab-upgrades/architecture.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;High-level GitLab Architecture Diagram&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;The above is the top level architecture diagram of our GitLab infrastructure. Here are the major components of the GitLab architecture and their functions: &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Gitaly&lt;/strong&gt;: Handles low-level Git operations for GitLab, such as interacting directly with the code repository present on disk. It’s important to mention that these code repositories are also stored on the same Gitaly nodes, using the attached Amazon Elastic Block Store (Amazon EBS) disks.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Praefect&lt;/strong&gt;: Praefect in GitLab acts as a manager, coordinating Gitaly nodes to maintain data consistency and high availability.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Sidekiq&lt;/strong&gt;: The background processing framework for GitLab written in Ruby. It handles asynchronous tasks in GitLab, ensuring smooth operation without blocking the main application.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;App Server&lt;/strong&gt;: The core web application server that serves the GitLab user interface and interacts with other components.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-importance-of-preparation&quot;&gt;The importance of preparation&lt;/h2&gt;

&lt;p&gt;Recognising the complexity of our task, we prioritised careful planning for a successful upgrade. We studied GitLab’s documentation, shared insights within the team, and planned to prevent data losses.&lt;/p&gt;

&lt;p&gt;To minimise disruptions from major upgrades or database migrations, we scheduled these during weekends. We also developed a checklist and a systematic approach for each upgrade, which include the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Diligently go through the release notes for each version of GitLab that falls within the scope of our upgrade.&lt;/li&gt;
  &lt;li&gt;Read through all dependencies like RDS, Redis, and Elasticsearch to ensure version compatibility.&lt;/li&gt;
  &lt;li&gt;Create documentation outlining new features, any deprecated elements, and changes that could potentially impact our operations.&lt;/li&gt;
  &lt;li&gt;Generate immutable AMIs for various components reflecting the new version of GitLab.&lt;/li&gt;
  &lt;li&gt;Revisit and validate all the backup plans.&lt;/li&gt;
  &lt;li&gt;Refresh staging environment with production data for accurate, realistic testing and performance checks, and validation of migration scripts under conditions similar to the actual setup.&lt;/li&gt;
  &lt;li&gt;Upgrade the staging environment.&lt;/li&gt;
  &lt;li&gt;Conduct extensive testing, incorporating both automated and manual functional testing, as well as load testing.&lt;/li&gt;
  &lt;li&gt;Conduct rollback tests on the staging environment to the previous version to confirm the rollback procedure’s reliability.&lt;/li&gt;
  &lt;li&gt;Inform all impacted stakeholders, and provide a defined timeline for upcoming upgrades.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We systematically follow GitLab’s official documentation for each &lt;a href=&quot;https://docs.gitlab.com/ee/update/index.html#upgrade-paths&quot;&gt;upgrade&lt;/a&gt;, ensuring compatibility across software versions and reviewing &lt;a href=&quot;https://docs.gitlab.com/ee/update/index.html#version-specific-upgrading-instructions&quot;&gt;specific instructions&lt;/a&gt; and changes, including any &lt;a href=&quot;https://docs.gitlab.com/ee/update/deprecations.html&quot;&gt;deprecations or removals&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-first-upgrade&quot;&gt;The first upgrade&lt;/h2&gt;

&lt;p&gt;Equipped with knowledge, backup plans, and a robust support system, we embarked on our first GitLab upgrade two years ago. We carefully followed our checklist, handling each important part systematically. GitLab comprises both stateful (Gitaly) and stateless (Praefect, Sidekiq, and App Server) components, all managed through auto-scaling groups. We use a &lt;strong&gt;‘create before destroy’&lt;/strong&gt; strategy for deploying stateless components and an &lt;strong&gt;‘in-place node rotation’&lt;/strong&gt; method via Terraform for stateful ones.&lt;/p&gt;

&lt;p&gt;We deployed key parts like Gitaly, Praefect, Sidekiq, App Servers, Network File System (NFS) server, and Elasticsearch in a specific sequence. Starting with Gitaly, followed by Praefect, then Sidekiq and App Servers, and finally NFS and Elasticsearch. Our thorough testing showed this order to be the most dependable and safe.&lt;/p&gt;

&lt;p&gt;However, the journey was full of challenges. For instance, we encountered issues such as the Gitaly cluster falling out of sync for monorepo and the Praefect server failing to distribute the load effectively. Praefect assigns a primary Gitaly node for each repository to host it. All write operations are sent to the repository’s primary node, while read requests are spread across all synced nodes in the Gitaly cluster. If the Gitaly nodes aren’t synced, Praefect will redirect all write and read operations to the repository’s primary node.&lt;/p&gt;

&lt;p&gt;Gitaly is a stateful application, we upgraded each Gitaly node with the latest AMI using an &lt;strong&gt;in-place node rotation&lt;/strong&gt; strategy. In older versions of GitLab (up to v14.0), if a Gitaly node is unhealthy, Praefect would immediately update the primary node for the repository to any healthy Gitaly node. After the rolling upgrade for a 3-node Gitaly cluster, repositories were mainly concentrated on only one Gitaly node.&lt;/p&gt;

&lt;p&gt;In our situation, a very busy monorepo was assigned to a Gitaly node that was also the main node for many other repositories. When real traffic began after deployment, the Gitaly node had trouble syncing the monorepo with the other nodes in the cluster.&lt;/p&gt;

&lt;p&gt;Because the Gitaly node was out of sync, Praefect started sending all changes and access requests for monorepo to this struggling Gitaly node. This increased the load on the Gitaly server, causing it to fail. We found this to be the main issue and decided to manually move our monorepo to a Gitaly node that was less crowded. We also added a step to validate primary node distribution to our deployment checklist.&lt;/p&gt;

&lt;p&gt;This immediate failover behaviour changed in &lt;a href=&quot;=https://gitlab.com/gitlab-org/gitaly/-/issues/3207&quot;&gt;GitLab version 14.1&lt;/a&gt;. Now, a primary is only elected lazily when a write request arrives for any repository. However, since we enabled maintenance mode before the Gitaly deployment, we didn’t receive any write requests. As a result, we did not see a shift in the primary node of the monorepo with new GitLab versions.&lt;/p&gt;

&lt;h2 id=&quot;regular-upgrades-our-new-normal&quot;&gt;Regular upgrades: Our new normal&lt;/h2&gt;

&lt;p&gt;Embracing the practice of consistent upgrades dramatically transformed the way we operate. We initiated frequent upgrades and implemented measures to reduce the actual deployment time.  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Perform all major testing in one day before deployment.&lt;/li&gt;
  &lt;li&gt;Prepare a detailed checklist to follow during the deployment activity.&lt;/li&gt;
  &lt;li&gt;Reduce the minimum number of App Server and Sidekiq Servers required just after we start the deployment.&lt;/li&gt;
  &lt;li&gt;Upgrade components like App Server and Sidekiq in parallel.&lt;/li&gt;
  &lt;li&gt;Automate smoke testing to examine all major workflows after deployment.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Leveraging the lessons learned and the experience gained with each upgrade, we successfully cut the time spent on the entire operation by 50%. The image-3 shows how we reduced our deployment time for major upgrades from 6 hours to 3 hours and our deployment time for minor upgrades from 4 to 1.5 hours.&lt;/p&gt;

&lt;p&gt;Each upgrade enriched our comprehensive knowledge base, equipping us with insights into the possible behaviours of each component under varying circumstances. Our growing experience and enhanced knowledge helped us achieve successful upgrades with less downtime with each deployment.&lt;/p&gt;

&lt;p&gt;Rather than moving up one minor version at a time, we learned about the feasibility of skipping versions. We began using the &lt;a href=&quot;https://gitlab-com.gitlab.io/support/toolbox/upgrade-path/&quot;&gt;GitLab Upgrade Path&lt;/a&gt;. This method allowed us to skip several versions, closing the distance to the latest version with fewer deployments. This approach enabled us to catch up on 24 months’ worth of upgrades in just 11 months, even though we started 14 months behind. &lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/no-version-left-behind-our-epic-journey-of-gitlab-upgrades/upgrade-hours.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Time taken in hrs for each upgrade. The blue line depicts major and the red line is for minor upgrades&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;h2 id=&quot;overcoming-challenges&quot;&gt;Overcoming challenges&lt;/h2&gt;

&lt;p&gt;Our journey was not without hurdles. We faced challenges in maintaining system stability during upgrades, navigating unexpected changes in functionality post upgrades, and ensuring data integrity.&lt;/p&gt;

&lt;p&gt;However, these challenges served as an opportunity for our team to innovate and create robust workarounds. Here are a few highlights:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Unexpected project distribution&lt;/strong&gt;: During upgrades and Gitaly server restarts, we observed unexpected migration of the monorepo to a crowded Gitaly server, resulting in higher rate limiting. We manually updated primary nodes for the monorepo and made this validation as a part of our deployment checklist.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NFS deprecation&lt;/strong&gt;: We migrated all required data to S3 buckets and deprecated NFS to become more resilient and independent of Availability Zone (AZ).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Handling unexpected Continuous Integration (CI) operations&lt;/strong&gt;: A sudden surge in CI operations sometimes resulted in rate limiting and interrupted more essential Git operations for developers. This is because GitLab uses different RPC calls and their concurrency for SSH and HTTP operations. We encouraged using HTTPS links for GitLab CI and automation script and SSH links for regular Git operations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Right-sizing resources&lt;/strong&gt;: We countered resource limitations by right-sizing our infrastructure, ensuring each component had optimal resources to function efficiently.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Performance testing&lt;/strong&gt;: We conducted performance testing of our GitLab using the &lt;a href=&quot;https://handbook.gitlab.com/handbook/support/workflows/gpt_quick_start&quot;&gt;GitLab Performance Tool (GPT)&lt;/a&gt;. In addition, we used our custom scripts to load test Grab specific use cases and mono repositories.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Limiting maintenance windows&lt;/strong&gt;: Each deployment required a maintenance window or downtime. To minimise this, we structured our deployment processes more efficiently, reducing potential downtime and ensuring uninterrupted service for users.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dependency on GitLab.com image registry&lt;/strong&gt;: We introduced measures to host necessary images internally, which increased our resilience and allowed us to cut ties with external dependencies.&lt;/p&gt;

&lt;h2 id=&quot;the-results&quot;&gt;The results&lt;/h2&gt;

&lt;p&gt;Through careful planning, we’ve improved our upgrade process, ensuring system stability and timely updates. We’ve also reduced the delay in aligning with official GitLab releases. The image below displays how the time delay between release date and deployment has been reduced with each upgrade. It sharply brought down from &lt;strong&gt;396 days (around 14 months)&lt;/strong&gt; to &lt;strong&gt;35 days&lt;/strong&gt;. &lt;/p&gt;

&lt;p&gt;At the time of this article, we’re just two minor versions behind the latest GitLab release, with a strong focus on security and resilience. We are also seeing a reduced number of reported issues after each upgrade.&lt;/p&gt;

&lt;p&gt;Our refined process has allowed us to perform regular updates without any service disruptions. We aim to leverage these learnings to automate our upgrade deployments, painting a positive picture for our future updates, marked by efficiency and stability.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/no-version-left-behind-our-epic-journey-of-gitlab-upgrades/days-since-deployed.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Time delay between official release date and date of deployment&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;h2 id=&quot;looking-ahead&quot;&gt;Looking ahead&lt;/h2&gt;

&lt;p&gt;Our dedication extends beyond staying current with the most recent GitLab versions. With stabilised deployment, we are now focusing on:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Automated upgrades&lt;/strong&gt;: Our efforts extend towards bringing in more automation to enhance efficiency. We’re already employing &lt;strong&gt;zero-downtime&lt;/strong&gt; automated upgrades for patch versions involving no database migrations, utilising GitLab pipelines. Looking forward, we plan to automate minor version deployments as well, ensuring minimal human intervention during the upgrade process.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Automated runner onboarding for service teams&lt;/strong&gt;: We’ve developed a &lt;strong&gt;‘Runner as a Service’&lt;/strong&gt; solution for our service teams. Service teams can create their dedicated runners by providing minimal details, while we manage these runners centrally. This setup allows the service team to stay focused on development, ensuring smooth operations.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Improved communication and data safety&lt;/strong&gt;: We’re regularly communicating new features and potential issues to our service teams. We also ensure targeted solutions for any disruptions. Additionally, we’re focusing on developing automated data validation via our data restoration process. &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Focus on development&lt;/strong&gt;: With stabilised updates, we’ve created an environment where our development teams can focus more on crafting new features and supporting ongoing work, rather than handling upgrade issues.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;key-takeaways&quot;&gt;Key takeaways&lt;/h2&gt;

&lt;p&gt;The upgrade process taught us the importance of adaptability, thorough preparation, effective communication, and continuous learning. Our ‘No Version Left Behind’ motto underscores the critical role of regular tech updates in boosting productivity, refining processes, and strengthening security. These insights will guide us as we navigate ongoing technological advancements.&lt;/p&gt;

&lt;p&gt;Below are the key areas in which we improved:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enhanced testing procedures&lt;/strong&gt;: We’ve fine-tuned our testing strategies, using both automated and manual testing for GitLab, and regularly conducting performance tests before upgrades.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Approvals&lt;/strong&gt;: We’ve designed approval workflows that allow us to obtain necessary clearances or approvals before each upgrade efficiently, further ensuring the smooth execution of our processes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Improved communication&lt;/strong&gt;: We’ve improved stakeholder communication, regularly sharing updates and detailed documents about new features, deprecated items, and significant changes with each upgrade.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Streamlined planning&lt;/strong&gt;: We’ve improved our upgrade planning, strictly following our checklist and rotating the role of Upgrade Ownership among team members.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Optimised activity time&lt;/strong&gt;: We’ve significantly reduced the time for production upgrade activity through advanced planning, automation, and eliminating unnecessary steps.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Efficient issue management&lt;/strong&gt;: We’ve improved our ability to handle potential GitLab upgrade issues, with minimal to no issues occurring. We’re prepared to handle any incidents that could cause an outage.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Knowledge base creation and automation&lt;/strong&gt;: We’ve created a GitLab knowledge base and continuously enhanced it with rich content, making it even more invaluable for training new team members and for reference during unexpected situations. We’ve also automated routine tasks to improve efficiency and reduce manual errors.&lt;/p&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Fri, 03 May 2024 00:10:10 +0000</pubDate>
        <link>https://engineering.grab.com/no-version-left-behind-our-epic-journey-of-gitlab-upgrades</link>
        <guid isPermaLink="true">https://engineering.grab.com/no-version-left-behind-our-epic-journey-of-gitlab-upgrades</guid>
        
        <category>stability</category>
        
        <category>automation</category>
        
        <category>optimisation</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>Ensuring data reliability and observability in risk systems</title>
        <description>&lt;p&gt;Grab has an in-house Risk Management platform called &lt;a href=&quot;https://www.grab.com/sg/business/defence/&quot;&gt;GrabDefence&lt;/a&gt; which relies on ingesting large amounts of data gathered from upstream services to power our heuristic risk rules and data science models in real time.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/data-observability/image4.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig 1. GrabDefence aggregates data from different upstream services&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;As Grab’s business grows, so does the amount of data. It becomes imperative that the data which fuels our risk systems is of reliable quality as any data discrepancy or missing data could impact fraud detection and prevention capabilities.&lt;/p&gt;

&lt;p&gt;We need to quickly detect any data anomalies, which is where data observability comes in.&lt;/p&gt;

&lt;h2 id=&quot;data-observability-as-a-solution&quot;&gt;Data observability as a solution&lt;/h2&gt;

&lt;p&gt;Data observability is a type of data operation (DataOps; similar to DevOps) where teams build visibility over the health and quality of their data pipelines. This enables teams to be notified of data quality issues, and allows teams to investigate and resolve these issues faster.&lt;/p&gt;

&lt;p&gt;We needed a solution that addresses the following issues:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Alerts for any data quality issues as soon as possible - so this means the observability tool had to work in real time.&lt;/li&gt;
  &lt;li&gt;With hundreds of data points to observe, we needed a neat and scalable solution which allows users to quickly pinpoint which data points were having issues.&lt;/li&gt;
  &lt;li&gt;A consistent way to compare, analyse, and compute data that might have different formats.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hence, we decided to use Flink to standardise data transformations, compute, and observe data trends quickly (in real time) and scalably.&lt;/p&gt;

&lt;h2 id=&quot;utilising-flink-for-real-time-computations-at-scale&quot;&gt;Utilising Flink for real-time computations at scale&lt;/h2&gt;

&lt;h3 id=&quot;what-is-flink&quot;&gt;What is Flink?&lt;/h3&gt;

&lt;p&gt;Flink SQL is a powerful, flexible tool for performing real-time analytics on streaming data. It allows users to query continuous data streams using standard SQL syntax, enabling complex event processing and data transformation within the Apache Flink ecosystem, which is particularly useful for scenarios requiring low-latency insights and decisions.&lt;/p&gt;

&lt;h3 id=&quot;how-we-used-flink-to-compute-data-output&quot;&gt;How we used Flink to compute data output&lt;/h3&gt;

&lt;p&gt;In Grab, data comes from multiple sources and while most of the data is in JSON format, the actual JSON structure differs between services. Because of JSON’s nested and dynamic data structure, it is difficult to consistently analyse the data – posing a significant challenge for real-time analysis.&lt;/p&gt;

&lt;p&gt;To help address this issue, Apache Flink SQL has the capability to manage such intricacies with ease. It offers specialised functions tailored for parsing and querying JSON data, ensuring efficient processing.&lt;/p&gt;

&lt;p&gt;Another standout feature of Flink SQL is the use of custom table functions, such as JSONEXPLOAD, which serves to deconstruct and flatten nested JSON structures into tabular rows. This transformation is crucial as it enables subsequent aggregation operations. By implementing a 5-minute tumbling window, Flink SQL can easily aggregate these now-flattened data streams. This technique is pivotal for monitoring, observing, and analysing data patterns and metrics in near real-time.&lt;/p&gt;

&lt;p&gt;Now that data is aggregated by Flink for easy analysis, we still needed a way to incorporate comprehensive monitoring so that teams could be notified of any data anomalies or discrepancies in real time.&lt;/p&gt;

&lt;h3 id=&quot;how-we-interfaced-the-output-with-datadog&quot;&gt;How we interfaced the output with Datadog &lt;/h3&gt;

&lt;p&gt;Datadog is the observability tool of choice in Grab, with many teams using Datadog for their service reliability observations and alerts. By aggregating data from Apache Flink and integrating it with Datadog, we can harness the synergy of real-time analytics and comprehensive monitoring. Flink excels in processing and aggregating data streams, which, when pushed to Datadog, can be further analysed and visualised. Datadog also provides seamless integration with collaboration tools like Slack, which enables teams to receive instant notifications and alerts.&lt;/p&gt;

&lt;p&gt;With Datadog’s out-of-the-box features such as anomaly detection, teams can identify and be alerted to unusual patterns or outliers in their data streams. Taking a proactive approach to monitoring is crucial in maintaining system health and performance as teams can be alerted, then collaborate quickly to diagnose and address anomalies.&lt;/p&gt;

&lt;p&gt;This integrated pipeline—from Flink’s real-time data aggregation to Datadog’s monitoring and Slack’s communication capabilities—creates a robust framework for real-time data operations. It ensures that any potential issues are quickly traced and brought to the team’s attention, facilitating a rapid response. Such an ecosystem empowers organisations to maintain high levels of system reliability and performance, ultimately enhancing the overall user experience.&lt;/p&gt;

&lt;h2 id=&quot;organising-monitors-and-alerts-using-out-of-the-box-solutions-from-datadog&quot;&gt;Organising monitors and alerts using out-of-the-box solutions from Datadog&lt;/h2&gt;

&lt;p&gt;Once we integrated Flink data into Datadog, we realised that it could become unwieldy to try to identify the data point with issues from hundreds of other counters.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/data-observability/image3.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig 2. Hundreds of data points on a graph make it hard to decipher which ones have issues&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;We decided to organise the counters according to the service stream it was coming from, and create individual monitors for each service stream. We used Datadog’s Monitor Summary tool to help visualise the total number of service streams we are reading from and the number of underlying data points within each stream.  &lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/data-observability/image2.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig 3. Data is grouped according to their source stream&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Within each individual stream, we used Datadog’s &lt;a href=&quot;https://docs.datadoghq.com/monitors/types/anomaly/&quot;&gt;Anomaly Detection&lt;/a&gt; feature to create an alert whenever a data point from the stream exceeds a predefined threshold. This can be configured by the service teams on Datadog.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/data-observability/image1.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig 4. Datadog’s built-in Anomaly Detection function triggers alerts whenever a data point exceeds a threshold&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;These alerts are then sent to a Slack channel where the Data team is informed when a data point of interest starts throwing anomalous values.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/data-observability/image5.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig 5. Datadog integration with Slack to help alert users&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;h2 id=&quot;impact&quot;&gt;Impact&lt;/h2&gt;

&lt;p&gt;Since the deployment of this data observability tool, we have seen significant improvement in the detection of anomalous values. If there are any anomalies or issues, we now get alerts within the same day (or hour) instead of days to weeks later.&lt;/p&gt;

&lt;p&gt;Organising the alerts according to source streams have also helped simplify the monitoring load and allows users to quickly narrow down and identify which pipeline has failed.&lt;/p&gt;

&lt;h2 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h2&gt;

&lt;p&gt;At the moment, this data observability tool is only implemented on selected checkpoints in GrabDefence. We plan to expand the observability tool’s coverage to include more checkpoints, and continue to refine the workflows to detect and resolve these data issues.&lt;/p&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Apr 2024 00:15:10 +0000</pubDate>
        <link>https://engineering.grab.com/data-observability</link>
        <guid isPermaLink="true">https://engineering.grab.com/data-observability</guid>
        
        <category>Data Science</category>
        
        <category>Security</category>
        
        <category>Risk</category>
        
        <category>Data observability</category>
        
        <category>Data reliability</category>
        
        
        <category>Data Science</category>
        
        <category>Engineering</category>
        
        <category>Security</category>
        
      </item>
    
      <item>
        <title>Grab Experiment Decision Engine - a Unified Toolkit for Experimentation</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This article introduces the GrabX Decision Engine, an internal open-source package that offers a comprehensive framework for designing and analysing experiments conducted on online experiment platforms. The package encompasses a wide range of functionalities, including a pre-experiment advisor, a post-experiment analysis toolbox, and other advanced tools. In this article, we explore the motivation behind the development of these functionalities, their integration into the unique ecosystem of Grab’s multi-sided marketplace, and how these solutions strengthen the culture and calibre of experimentation at Grab.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;Today, &lt;a href=&quot;/building-grab-s-experimentation-platform&quot;&gt;Grab’s Experimentation (GrabX) platform&lt;/a&gt; orchestrates the testing of thousands of experimental variants each week. As the platform continues to expand and manage a growing volume of experiments, the need for dependable, scalable, and trustworthy experimentation tools becomes increasingly critical for data-driven and evidence-based 
decision-making.&lt;/p&gt;

&lt;p&gt;In our previous article, we presented the &lt;a href=&quot;https://engineering.grab.com/automated-experiment-analysis&quot;&gt;Automated Experiment Analysis&lt;/a&gt; application, a tool designed to automate data pipelines for analyses. However, during the development of this application for Grab’s experimenter community, we noticed a prevailing trend: experiments were predominantly analysed on a one-by-one, manual basis. While such a federated approach may be needed in a few cases, it presents numerous challenges at 
the organisational level:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Lack of a contextual toolkit&lt;/strong&gt;: GrabX facilitates executing a diverse range of experimentation designs, catering to the varied needs and contexts of different tech teams across the organisation. However, experimenters may often rely on generic online tools for experiment configurations (e.g. sample size calculations), which were not specifically designed to cater to the nuances of GrabX experiments or the recommended evaluation method, given the design. This is exacerbated by the fact 
that most online tutorials or courses on experimental design do not typically address the nuances of multi-sided marketplaces, and cannot consider the nature or constraints of specific experiments.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Lack of standards&lt;/strong&gt;: In this federated model, the absence of standardised and vetted practices can lead to reliability issues. In some cases, these can include poorly designed experiments, inappropriate evaluation methods, suboptimal testing choices, and unreliable inferences, all of which are difficult to monitor and rectify.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Lack of scalability and efficiency&lt;/strong&gt;: Experimenters, coming from varied backgrounds and possessing distinct skill sets, may adopt significantly different approaches to experimentation and inference. This diversity, while valuable, often impedes the transferability and sharing of methods, hindering a cohesive and scalable experimentation framework. Additionally, this variance in methods can extend the lifecycle of experiment analysis, as disagreements over approaches may give rise to 
repeated requests for review or modification.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;p&gt;To address these challenges, we developed the GrabX Decision Engine, a Python package open-sourced internally across all of Grab’s development platforms. Its central objective is to institutionalise best practices in experiment efficiency and analytics, thereby ensuring the derivation of precise and reliable conclusions from each experiment.&lt;/p&gt;

&lt;p&gt;In particular, this unified toolkit significantly enhances our end-to-end experimentation processes by:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Ensuring compatibility with GrabX and Automated Experiment Analysis&lt;/strong&gt;: The package is fully integrated with the &lt;a href=&quot;https://engineering.grab.com/automated-experiment-analysis&quot;&gt;Automated Experiment Analysis&lt;/a&gt; app, and provides analytics and test results tailored to the designs supported by GrabX. The outcomes can be further used for other downstream jobs, e.g. market modelling, simulation-based calibrations, or auto-adaptive configuration tuning.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Standardising experiment analytics&lt;/strong&gt;: By providing a unified framework, the package ensures that the rationale behind experiment design and the interpretation of analysis results adhere to a company-wide standard, promoting consistency and ease of review across different teams.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Enhancing collaboration and quality&lt;/strong&gt;: As an open-source package, it not only fosters a collaborative culture but also upholds quality through peer reviews. It invites users to tap into a rich pool of features while encouraging contributions that refine and expand the toolkit’s capabilities.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The package is designed for everyone involved in the experimentation process, with data scientists and product analysts being the primary users. Referred to as experimenters in this article, these key stakeholders can not only leverage the existing capabilities of the package to support their projects, but can also contribute their own innovations. Eventually, the experiment results and insights generated from the package via the &lt;a href=&quot;https://engineering.grab.com/automated-experiment-analysis&quot;&gt;Automated Experiment Analysis&lt;/a&gt; app have an even wider reach to stakeholders across all functions.&lt;/p&gt;

&lt;p&gt;In the following section, we go deeper into the key functionalities of the package.&lt;/p&gt;

&lt;h2 id=&quot;feature-details&quot;&gt;Feature details&lt;/h2&gt;

&lt;p&gt;The package comprises three key components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;An experimentation trusted advisor&lt;/li&gt;
  &lt;li&gt;A comprehensive post-experiment analysis toolbox&lt;/li&gt;
  &lt;li&gt;Advanced tools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These have been built taking into account the type of experiments we typically run at Grab. To understand their functionality, it’s useful to first discuss the key experimental designs supported by GrabX.&lt;/p&gt;

&lt;h3 id=&quot;a-note-on-experimental-designs&quot;&gt;A note on experimental designs&lt;/h3&gt;

&lt;p&gt;While there is a wide variety of specific experimental designs implemented, they can be bucketed into two main categories: a &lt;strong&gt;between-subject&lt;/strong&gt; design and a &lt;strong&gt;within-subject&lt;/strong&gt; design.&lt;/p&gt;

&lt;p&gt;In a between-subject design, participants — like our app users, driver-partners, and merchant-partners — are split into experimental groups, and each group gets exposed to a distinct condition throughout the experiment. One challenge in this design is that each participant may provide multiple observations to our experimental analysis sample, causing a high within-subject correlation among observations and deviations between the randomisation and session unit. This can affect the accuracy of 
pre-experiment power analysis, and post-experiment inference, since it necessitates adjustments, e.g. clustering of standard errors when conducting hypothesis testing.&lt;/p&gt;

&lt;p&gt;Conversely, a within-subject design involves every participant experiencing all conditions. Marketplace-level switchback experiments are a common GrabX use case, where a timeslice becomes the experimental unit. This design not only faces the aforementioned challenges, but also creates other complications that need to be accounted for, such as spillover effects across timeslices.&lt;/p&gt;

&lt;p&gt;Designing and analysing the results of both experimental approaches requires careful nuanced statistical tools. Ensuring proper duration, sample size, controlling for confounders, and addressing potential biases are important considerations to enhance the validity of the results.&lt;/p&gt;

&lt;h3 id=&quot;trusted-advisor&quot;&gt;Trusted Advisor&lt;/h3&gt;

&lt;p&gt;The first key component of the Decision Engine is the Trusted Advisor, which provides a recommendation to the experimenter on key experiment attributes to be considered when preparing the experiment. This is dependent on the design; at a minimum, the experimenter needs to define whether the experiment design is between- or within-subject.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The between-subject design&lt;/strong&gt;: We strongly recommend that experimenters utilise the “Trusted Advisor” feature in the Decision Engine for estimating their required sample size. This is designed to account for the multiple observations per user the experiment is expected to generate and adjusts for the presence of clustered errors (Moffatt, 2020; List, Sadoff, &amp;amp; Wagner, 2011). This feature allows users to input their data, either as a PySpark or Pandas dataframe. Alternatively, a function is 
provided to extract summary statistics from their data, which can then be inputted into the Trusted Advisor. Obtaining the data beforehand is actually not mandatory; users have the option to directly query the recommended sample size based on common metrics derived from a regular data pipeline job. These functionalities are illustrated in the flowchart below.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/grabx-decision-engine/image1.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Trusted Advisor functionalities&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Furthermore, the Trusted Advisor feature can identify the underlying characteristics of the data, whether it’s passed directly, or queried from our common metrics database. This enables it to determine the appropriate power analysis for the experiment, without further guidance. For instance, it can detect if the target metric is a binary decision variable, and will adapt the power analysis to the correct context.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The within-subject design&lt;/strong&gt;: In this case, we instead provide a best practices guideline to follow. Through our experience supporting various Tech Families running switchback experiments, we have observed various challenges highly dependent on the use case. This makes it difficult to create a one-size-fits-all solution.&lt;/p&gt;

&lt;p&gt;For instance, an important factor affecting the final sample size requirement is how frequently treatments switch, which is also tied to what data granularity is appropriate to use in the post-experiment analysis. These considerations are dependent on, among other factors, how quickly a given treatment is expected to cause an effect. Some treatments may take effect relatively quickly (near-instantly, e.g. if applied to price checks), while others may take significantly longer (e.g. 15-30 minutes because they may require a trip to be completed). This has further consequences, e.g. autocorrelation between observations within a treatment window, spillover effects between different treatment windows, requirements for cool-down windows when treatments switch, etc.&lt;/p&gt;

&lt;p&gt;Another issue we have identified from analysing the history of experiments on our platform is that a significant portion is prone to issues related to sample ratio mismatch (SRM). We therefore also heavily emphasise the post-experiment analysis corrections and robustness checks that are needed in switchback experiments, and do not simply rely on pre-experiment guidance such as power analysis.&lt;/p&gt;

&lt;h3 id=&quot;post-experiment-analysis&quot;&gt;Post-experiment analysis&lt;/h3&gt;

&lt;p&gt;Upon completion of the experiment, a comprehensive toolbox for post-experiment analysis is available. This toolbox consists of a wide range of statistical tests, ranging from normality tests to non-parametric and parametric tests. Here is an overview of the different types of tests included in the toolbox for different experiment setups:&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/grabx-decision-engine/image2.png&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Tests supported by the post-experiment analysis component&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Though we make all the relevant tests available, the package sets a default list of output. With just two lines of code specifying the desired experiment design, experimenters can easily retrieve the recommended results, as summarised in the following table.&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
&lt;thead&gt;
  &lt;tr&gt;
    &lt;th&gt;Types&lt;/th&gt;
    &lt;th&gt;Details&lt;/th&gt;
  &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
    &lt;td&gt;Basic statistics&lt;/td&gt;
    &lt;td&gt;The mean, variance, and sample size of Treatment and Control &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Uplift tests&lt;/td&gt;
    &lt;td&gt;Welch&apos;s t-test;&lt;br /&gt;Non-parametric tests, such as Wilcoxon signed-rank test and Mann-Whitney U Test&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Misc tests&lt;/td&gt;
    &lt;td&gt;Normality tests such as the Shapiro-Wilk test, Anderson-Darling test, and Kolmogorov-Smirnov test;&lt;br /&gt;Levene test which assesses the equality of variances between groups&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Regression models&lt;/td&gt;
    &lt;td&gt;A standard OLS/Logit model to estimate the treatment uplift;&lt;br /&gt;&lt;b&gt;Recommended regression models&lt;/b&gt; &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Warning&lt;/td&gt;
    &lt;td&gt;Provides a warning or notification related to the statistical analysis or results, for example:&lt;br /&gt;- Lack of variation in the variables&lt;br /&gt;- Sample size is too small&lt;br /&gt;- Too few randomisation units which will lead to under-estimated standard errors&lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;recommended-regression-models&quot;&gt;Recommended regression models&lt;/h3&gt;

&lt;p&gt;Besides reporting relevant statistical test results, we adopt regression models to leverage their flexibility in controlling for confounders, fixed effects and heteroskedasticity, as is commonly observed in our experiments. As mentioned in the section “A note on experimental design”, each approach has different implications on the achieved randomisation, and hence requires its own customised regression models.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Between-subject design&lt;/strong&gt;: the observations are not independent and identically distributed (i.i.d) but clustered due to repeated observations of the same experimental units. Therefore, we set the default clustering level at the participant level in our regression models, considering that most of our between-subject experiments only take a small portion of the population (Abadie et al., 2022).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Within-subject design&lt;/strong&gt;: this has further challenges, including spillover effects and randomisation imbalances. As a result, they often require better control of confounding factors. We adopt panel data methods and impose time fixed effects, with no option to remove them. Though users have the flexibility to define these themselves, we use hourly fixed effects as our default as we have found that these match the typical seasonality we observe in marketplace metrics. Similar to between-subject 
designs, we use standard error corrections for clustered errors, and small number of clusters, as the default. Our API is flexible for users to include further controls, as well as further fixed effects to adapt the estimator to geo-timeslice designs.&lt;/p&gt;

&lt;h3 id=&quot;advanced-tools&quot;&gt;Advanced tools&lt;/h3&gt;

&lt;p&gt;Apart from the pre-experiment Trusted Advisor and the post-experiment Analysis Toolbox, we have enriched this package by providing more advanced tools. Some of them are set as a default feature in the previous two components, while others are ad-hoc capabilities which the users can utilise via calling the functions directly.&lt;/p&gt;

&lt;h4 id=&quot;variance-reduction&quot;&gt;Variance reduction&lt;/h4&gt;

&lt;p&gt;We bring in multiple methods to reduce variance and improve the power and sensitivity of experiments:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stratified sampling: recognised for reducing variance during assignment&lt;/li&gt;
  &lt;li&gt;Post stratification: a post-assignment variance reduction technique&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://exp-platform.com/Documents/2013-02-CUPED-ImprovingSensitivityOfControlledExperiments.pdf&quot;&gt;CUPED&lt;/a&gt;: utilises ANCOVA to decrease variances&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/2106.07263.pdf&quot;&gt;MLRATE&lt;/a&gt;: an extension of CUPED that allows for the use of non-linear / machine learning models&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These approaches offer valuable ways to mitigate variance and improve the overall effectiveness of experiments. The experimenters can directly access these ad hoc capabilities via the package.&lt;/p&gt;

&lt;h4 id=&quot;multiple-comparisons-problem&quot;&gt;Multiple comparisons problem&lt;/h4&gt;

&lt;p&gt;A multiple comparisons problem occurs when multiple hypotheses are simultaneously tested, leading to a higher likelihood of false positives. To address this, we implement various statistical correction techniques in this package, as illustrated below.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/grabx-decision-engine/image3.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Statistical correction techniques&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Experimenters can specify if they have concerns about the dependency of the tests and whether the test results are expected to be negatively related. This capability will adopt the following procedures and choose the relevant tests to mitigate the risk of false positives accordingly:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;False Discovery Rate (FDR) procedures, which control the expected rate of false discoveries.&lt;/li&gt;
  &lt;li&gt;Family-wise Error Rate (FWER) procedures, which control the probability of making at least one false discovery within a set of related tests referred to as a family.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;multiple-treatments-and-unequal-treatment-sizes&quot;&gt;Multiple treatments and unequal treatment sizes&lt;/h4&gt;

&lt;p&gt;We developed a capability to deal with experiments where there are multiple treatments. This capability employs a conservative approach to ensure that the size reaches a minimum level where any pairwise comparison between the control and treatment groups has a sufficient sample size.&lt;/p&gt;

&lt;h4 id=&quot;heterogeneous-treatment-effects&quot;&gt;Heterogeneous treatment effects&lt;/h4&gt;

&lt;p&gt;Heterogeneous treatment effects refer to a situation where the treatment effect varies across different groups or subpopulations within a larger population. For instance, it may be of interest to examine treatment effects specifically on rainy days compared to non-rainy days. We have incorporated this functionality into the tests for both experiment designs. By enabling this feature, we facilitate a more nuanced analysis that accounts for potential variations in treatment effects based on different factors or contexts.&lt;/p&gt;

&lt;h2 id=&quot;maintenance-and-support&quot;&gt;Maintenance and support&lt;/h2&gt;

&lt;p&gt;The package is available across all internal DS/Machine Learning platforms and individual local development environments within Grab. Its source code is openly accessible to all developers within Grab and its release adheres to a semantic release standard.&lt;/p&gt;

&lt;p&gt;In addition to the technical maintenance efforts, we have introduced a dedicated committee and a workspace to address issues that may extend beyond the scope of the package’s current capabilities.&lt;/p&gt;

&lt;h3 id=&quot;experiment-council&quot;&gt;Experiment Council&lt;/h3&gt;

&lt;p&gt;Within Grab, there is a dedicated committee known as the ‘Experiment Council’. This committee includes data scientists, analysts, and economists from various functions. One of their responsibilities is to collaborate to enhance and maintain the package, as well as guide users in effectively utilising its functionalities. The Experiment Council plays a crucial role in enhancing the overall operational excellence of conducting experiments and deriving meaningful insights from them.&lt;/p&gt;

&lt;h3 id=&quot;grabcausal-methodology-bank&quot;&gt;GrabCausal Methodology Bank&lt;/h3&gt;

&lt;p&gt;Experimenters frequently encounter challenges regarding the feasibility of conducting experiments for causal problems. To address this concern, we have introduced an alternative workspace called GrabCausal Methodology Bank. Similar to the internal open-source nature of this project, the GrabCausal Methodology bank is open to contributions from all users within Grab. It provides a collaborative space where users can readily share their code, case studies, guidelines, and suggestions related to 
causal methodologies. By fostering an open and inclusive environment, this workspace encourages knowledge sharing and promotes the advancement of causal research methods.&lt;/p&gt;

&lt;p&gt;The workspace functions as a platform, which now exhibits a wide range of commonly used methods, including Diff-in-Diff, Event studies, Regression Discontinuity Designs (RDD), Instrumental Variables (IV), Bayesian structural time series, and Bunching. Additionally, we are dedicated to incorporating more, such as Synthetic control, Double ML (Chernozhukov et al. 2018), DAG discovery/validation, etc., to further enhance our offerings in this space.&lt;/p&gt;

&lt;h2 id=&quot;learnings&quot;&gt;Learnings&lt;/h2&gt;

&lt;p&gt;Over the past few years, we have invested in developing and expanding this package. Our initial motivation was humble yet motivating - to contribute to improving the quality of experimentation at Grab, helping it develop from its initial start-up modus operandi to a more consolidated, rigorous, and guided approach.&lt;/p&gt;

&lt;p&gt;Throughout this journey, we have learned that prioritisation holds the utmost significance in open-source projects of this nature; the majority of user demands can be met through relatively small yet pivotal efforts. By focusing on these core capabilities, we avoid spreading resources too thinly across all areas at the initial stage of planning and development.&lt;/p&gt;

&lt;p&gt;Meanwhile, we acknowledge that there is still a significant journey ahead. While the package now focuses solely on individual experiments, an inherent challenge in online-controlled experimentation platforms is the interference between experiments (Gupta, et al, 2019). A recent development in the field is to embrace simultaneous tests (&lt;a href=&quot;https://exp-platform.com/Documents/2013%2520controlledExperimentsAtScale.pdf&quot;&gt;Microsoft&lt;/a&gt;, &lt;a href=&quot;https://medium.datadriveninvestor.com/how-google-conducts-more-better-faster-experiments-3b91446cd3b5&quot;&gt;Google&lt;/a&gt;, &lt;a href=&quot;https://www.infoq.com/news/2016/12/large-experimentation-spotify/&quot;&gt;Spotify&lt;/a&gt; and &lt;a href=&quot;https://cxl.com/blog/can-you-run-multiple-ab-tests-at-the-same-time/&quot;&gt;booking.com and Optimizely&lt;/a&gt;), and to carefully consider the tradeoff between accuracy and velocity.&lt;/p&gt;

&lt;p&gt;The key to overcoming this challenge will be a close collaboration between the community of experimenters, the teams developing this unified toolkit, and the GrabX platform engineers. In particular, the platform developers will continue to enrich the experimentation SDK by providing diverse assignment strategies, sampling mechanisms, and user interfaces to manage potential inference risks better. Simultaneously, the community of experimenters can coordinate among themselves effectively to 
avoid severe interference, which will also be monitored by GrabX. Last but not least, the development of this unified toolkit will also focus on monitoring, evaluating, and managing inter-experiment interference.&lt;/p&gt;

&lt;p&gt;In addition, we are committed to keeping this package in sync with industry advancements. Many existing tools in this package, despite being labelled as “advanced” in the earlier discussions, are still relatively simplified. For instance,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Incorporating standard errors clustering based on the diverse assignment and sampling strategies requires attention (Abadie, et al, 2023).&lt;/li&gt;
  &lt;li&gt;Sequential testing will play a vital role in detecting uplifts earlier and safely, avoiding p-hacking. One recent innovation is the “always valid inference” (Johari, et al., 2022)&lt;/li&gt;
  &lt;li&gt;The advancements in investigating heterogeneous effects, such as Causal Forest (Athey and Wager, 2019), have extended beyond linear approaches, now incorporating nonlinear and more granular analyses.&lt;/li&gt;
  &lt;li&gt;Estimating the long-term treatment effects observed from short-term follow-ups is also a long-term objective, and one approach is using a Surrogate Index (Athey, et al 2019).&lt;/li&gt;
  &lt;li&gt;Continuous effort is required to stay updated and informed about the latest advancements in statistical testing methodologies, to ensure accuracy and effectiveness.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This article marks the beginning of our journey towards automating the experimentation and product decision-making process among the data scientist community. We are excited about the prospect of expanding the toolkit further in these directions. Stay tuned for more updates and posts.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Abadie, Alberto, et al. “When should you adjust standard errors for clustering?.” The Quarterly Journal of Economics 138.1 (2023): 1-35.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Athey, Susan, et al. “The surrogate index: Combining short-term proxies to estimate long-term treatment effects more rapidly and precisely.” No. w26463. National Bureau of Economic Research, 2019.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Athey, Susan, and Stefan Wager. “Estimating treatment effects with causal forests: An application.” Observational studies 5.2 (2019): 37-51.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Chernozhukov, Victor, et al. “Double/debiased machine learning for treatment and structural parameters.” (2018): C1-C68.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Facure, Matheus. Causal Inference in Python. O’Reilly Media, Inc., 2023.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Gupta, Somit, et al. “Top challenges from the first practical online controlled experiments summit.” ACM SIGKDD Explorations Newsletter 21.1 (2019): 20-35.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Huntington-Klein, Nick. The Effect: An Introduction to Research Design and Causality. CRC Press, 2021.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Imbens, Guido W. and Donald B. Rubin. Causal Inference for Statistics, Social, and Biomedical Sciences: An Introduction. Cambridge University Press, 2015.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Johari, Ramesh, et al. “Always valid inference: Continuous monitoring of a/b tests.” Operations Research 70.3 (2022): 1806-1821.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;List, John A., Sally Sadoff, and Mathis Wagner. “So you want to run an experiment, now what? Some simple rules of thumb for optimal experimental design.” Experimental Economics 14 (2011): 439-457.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Moffatt, Peter. Experimetrics: Econometrics for Experimental Economics. Bloomsbury Publishing, 2020.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Apr 2024 02:22:10 +0000</pubDate>
        <link>https://engineering.grab.com/grabx-decision-engine</link>
        <guid isPermaLink="true">https://engineering.grab.com/grabx-decision-engine</guid>
        
        <category>Data Science</category>
        
        <category>Experiment</category>
        
        <category>Statistics</category>
        
        <category>Econometrics</category>
        
        <category>Python Package</category>
        
        
        <category>Engineering</category>
        
        <category>Data Science</category>
        
      </item>
    
      <item>
        <title>Iris - Turning observations into actionable insights for enhanced decision making</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Iris&lt;/strong&gt; (/ˈaɪrɪs/), a name inspired by the Olympian mythological figure who personified the rainbow and served as the messenger of the gods, is a comprehensive observability platform for Extract, Transform, Load (ETL) jobs. Just as the mythological Iris connected the gods to humanity, our Iris platform bridges the gap between raw data and meaningful insights, serving the needs of data-driven organisations. Specialising in meticulous monitoring and tracking of &lt;strong&gt;Spark&lt;/strong&gt; and &lt;strong&gt;Presto&lt;/strong&gt; jobs, Iris stands as a transformative tool for peak observability and effective decision-making.&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/iris/image14.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;
  &lt;/figure&gt;
&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Iris captures critical job metrics &lt;strong&gt;right at the Java Virtual Machine (JVM) level&lt;/strong&gt;, including but not limited to runtime, CPU and memory utilisation rates, garbage collection statistics, &lt;strong&gt;stage and task execution details&lt;/strong&gt;, and much more.&lt;/li&gt;
  &lt;li&gt;Iris not only regularly records these metrics but also supports &lt;strong&gt;real-time monitoring&lt;/strong&gt; and &lt;strong&gt;offline analytics&lt;/strong&gt; of metrics in the data lake. This gives you multi-faceted control and insights into the operational aspects of your workloads.&lt;/li&gt;
  &lt;li&gt;Iris gives you an overview of your jobs, &lt;strong&gt;predicts&lt;/strong&gt; if your jobs are over or under-provisioned, and provides suggestions on how to optimise resource usage and save costs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;understanding-the-needs&quot;&gt;Understanding the needs&lt;/h2&gt;

&lt;p&gt;When examining ETL job monitoring across various platforms, a common deficiency became apparent. Existing tools could only provide CPU and memory usage data at the instance level, where an instance could refer to an EC2 unit or a Kubernetes pod with resources bound to the container level.&lt;/p&gt;

&lt;p&gt;However, this CPU and memory usage data included usage from the operating system and other background tasks, making it difficult to &lt;strong&gt;isolate usage specific to Spark jobs&lt;/strong&gt; (JVM level). A sizeable fraction of resource consumption, thus, could not be attributed directly to our ETL jobs. This lack of granularity posed significant challenges when trying to perform effective resource optimisation for individual jobs.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/iris/image8.png&quot; width=&quot;70%&quot; alt=&quot;&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Gap between total instance and JVM provisioned resources&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;The situation was further complicated when compute instances were shared among various jobs. In such cases, determining the precise resource consumption for a specific job became nearly impossible. This made in-depth analysis and performance optimisation of specific jobs a complex and often ineffective process.&lt;/p&gt;

&lt;p&gt;In the initial stages of my career in Spark, I took the reins of handling SEGP ETL jobs deployed in Chimera. Then, Chimera did not possess any tool for observing and understanding SEGP jobs. The lack of an efficient tool for &lt;strong&gt;close-to-real-time visualisation&lt;/strong&gt; of Spark cluster/job metrics, profiling code &lt;strong&gt;class/function runtime durations&lt;/strong&gt;, and investigating deep-level job metrics to assess CPU and memory usage, posed a significant challenge even back then.&lt;/p&gt;

&lt;p&gt;In the quest for solutions within Grab, I found no tool that could fulfill all these needs. This prompted me to extend my search beyond the organisation, leading me to discover that Uber had an exceptional tool known as the &lt;strong&gt;JVM Profiler&lt;/strong&gt;. This tool could collect JVM metrics and profile the job. Further research also led me to &lt;strong&gt;sparkMeasure&lt;/strong&gt;, a standalone tool known for its ability to measure Spark metrics on-the-fly without any code changes.&lt;/p&gt;

&lt;p&gt;This personal research and journey highlights the importance of a comprehensive, in-depth observability tool - emphasising the need that Iris aims to fulfill in the world of ETL job monitoring. Through this journey, Iris was ideated, named after the Greek deity, encapsulating the mission to bridge the gap between the realm of raw ETL job metrics and the world of actionable insights.&lt;/p&gt;

&lt;h2 id=&quot;observability-with-iris&quot;&gt;Observability with Iris&lt;/h2&gt;

&lt;h3 id=&quot;platform-architecture&quot;&gt;Platform architecture&lt;/h3&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/iris/image9.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Platform architecture of Iris&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Iris’s robust architecture is designed to smartly deliver observability into Spark jobs with high reliability. It consists of three main modules: Metrics Collector, Kafka Queue, and Telegraf, InfluxDB, and Grafana (TIG) Stack.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Metrics Collector&lt;/strong&gt;: This module listens to Spark jobs, collects metrics, and funnels them to the Kafka queue. What sets this apart is its unobstructive nature - there is no need for end-users to update their application code or notebook.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kafka Queue&lt;/strong&gt;: Serving as an asynchronous deliverer of metrics messages, Kafka is leveraged to prevent Iris from becoming another bottleneck slowing down user jobs. By functioning as a message queue, it enables the efficient processing of metric data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TIG Stack&lt;/strong&gt;: This component is utilised for real-time monitoring, making visualising performance metrics a cinch. The TIG stack proves to be an effective solution for real-time data visualisation.&lt;/p&gt;

&lt;p&gt;For offline analytics, Iris pushes metrics data from Kafka into our data lake. This creates a wealth of historical data that can be utilised for future research, analysis, and predictions. The strategic combination of real-time monitoring and offline analysis forms the basis of Iris’s ability to provide valuable insights.&lt;/p&gt;

&lt;p&gt;Next, we will delve into how Iris collects the metrics.&lt;/p&gt;

&lt;h3 id=&quot;data-collection&quot;&gt;Data collection&lt;/h3&gt;

&lt;p&gt;Iris’s metrics is now primarily driven by two tools that operate under the Metrics Collector module: JVM Profiler and sparkMeasure.&lt;/p&gt;

&lt;h4 id=&quot;jvm-profiler&quot;&gt;JVM Profiler&lt;/h4&gt;

&lt;p&gt;As mentioned earlier, JVM Profiler is an exceptional tool that helps to collect and profile metrics at JVM level.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/iris/image10.png&quot; width=&quot;70%&quot; alt=&quot;&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Java process for the JVM Profiler tool&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Uber JVM Profiler supports the following features:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Debug memory usage for all your Spark application executors, including java heap memory, non-heap memory, native memory (VmRSS, VmHWM), memory pool, and buffer pool (directed/mapped buffer).&lt;/li&gt;
  &lt;li&gt;Debug CPU usage, garbage collection time for all Spark executors.&lt;/li&gt;
  &lt;li&gt;Debug arbitrary Java class methods (how many times they run, how long they take), also called Duration Profiling.&lt;/li&gt;
  &lt;li&gt;Debug arbitrary Java class method call and trace its argument value, also known as Argument Profiling.&lt;/li&gt;
  &lt;li&gt;Do Stacktrack Profiling and generate flamegraph to visualise CPU time spent for the Spark application.&lt;/li&gt;
  &lt;li&gt;Debug I/O metrics (disk read/write bytes for the application, CPU iowait for the machine).&lt;/li&gt;
  &lt;li&gt;Debug JVM Thread Metrics like Count of Total Threads, Peak Threads, Live/Active Threads, and newThreads.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example metrics (&lt;a href=&quot;https://gitlab.myteksi.net/olympus/iris/jvm-profiler&quot;&gt;Source code&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
        &quot;nonHeapMemoryTotalUsed&quot;: 11890584.0,
        &quot;bufferPools&quot;: [
                {
                        &quot;totalCapacity&quot;: 0,
                        &quot;name&quot;: &quot;direct&quot;,
                        &quot;count&quot;: 0,
                        &quot;memoryUsed&quot;: 0
                },
                {
                        &quot;totalCapacity&quot;: 0,
                        &quot;name&quot;: &quot;mapped&quot;,
                        &quot;count&quot;: 0,
                        &quot;memoryUsed&quot;: 0
                }
        ],
        &quot;heapMemoryTotalUsed&quot;: 24330736.0,
        &quot;epochMillis&quot;: 1515627003374,
        &quot;nonHeapMemoryCommitted&quot;: 13565952.0,
        &quot;heapMemoryCommitted&quot;: 257425408.0,
        &quot;memoryPools&quot;: [
                {
                        &quot;peakUsageMax&quot;: 251658240,
                        &quot;usageMax&quot;: 251658240,
                        &quot;peakUsageUsed&quot;: 1194496,
                        &quot;name&quot;: &quot;Code Cache&quot;,
                        &quot;peakUsageCommitted&quot;: 2555904,
                        &quot;usageUsed&quot;: 1173504,
                        &quot;type&quot;: &quot;Non-heap memory&quot;,
                        &quot;usageCommitted&quot;: 2555904
                },
                {
                        &quot;peakUsageMax&quot;: -1,
                        &quot;usageMax&quot;: -1,
                        &quot;peakUsageUsed&quot;: 9622920,
                        &quot;name&quot;: &quot;Metaspace&quot;,
                        &quot;peakUsageCommitted&quot;: 9830400,
                        &quot;usageUsed&quot;: 9622920,
                        &quot;type&quot;: &quot;Non-heap memory&quot;,
                        &quot;usageCommitted&quot;: 9830400
                },
                {
                        &quot;peakUsageMax&quot;: 1073741824,
                        &quot;usageMax&quot;: 1073741824,
                        &quot;peakUsageUsed&quot;: 1094160,
                        &quot;name&quot;: &quot;Compressed Class Space&quot;,
                        &quot;peakUsageCommitted&quot;: 1179648,
                        &quot;usageUsed&quot;: 1094160,
                        &quot;type&quot;: &quot;Non-heap memory&quot;,
                        &quot;usageCommitted&quot;: 1179648
                },
                {
                        &quot;peakUsageMax&quot;: 1409286144,
                        &quot;usageMax&quot;: 1409286144,
                        &quot;peakUsageUsed&quot;: 24330736,
                        &quot;name&quot;: &quot;PS Eden Space&quot;,
                        &quot;peakUsageCommitted&quot;: 67108864,
                        &quot;usageUsed&quot;: 24330736,
                        &quot;type&quot;: &quot;Heap memory&quot;,
                        &quot;usageCommitted&quot;: 67108864
                },
                {
                        &quot;peakUsageMax&quot;: 11010048,
                        &quot;usageMax&quot;: 11010048,
                        &quot;peakUsageUsed&quot;: 0,
                        &quot;name&quot;: &quot;PS Survivor Space&quot;,
                        &quot;peakUsageCommitted&quot;: 11010048,
                        &quot;usageUsed&quot;: 0,
                        &quot;type&quot;: &quot;Heap memory&quot;,
                        &quot;usageCommitted&quot;: 11010048
                },
                {
                        &quot;peakUsageMax&quot;: 2863661056,
                        &quot;usageMax&quot;: 2863661056,
                        &quot;peakUsageUsed&quot;: 0,
                        &quot;name&quot;: &quot;PS Old Gen&quot;,
                        &quot;peakUsageCommitted&quot;: 179306496,
                        &quot;usageUsed&quot;: 0,
                        &quot;type&quot;: &quot;Heap memory&quot;,
                        &quot;usageCommitted&quot;: 179306496
                }
        ],
        &quot;processCpuLoad&quot;: 0.0008024004394748531,
        &quot;systemCpuLoad&quot;: 0.23138430784607697,
        &quot;processCpuTime&quot;: 496918000,
        &quot;appId&quot;: null,
        &quot;name&quot;: &quot;24103@machine01&quot;,
        &quot;host&quot;: &quot;machine01&quot;,
        &quot;processUuid&quot;: &quot;3c2ec835-749d-45ea-a7ec-e4b9fe17c23a&quot;,
        &quot;tag&quot;: &quot;mytag&quot;,
        &quot;gc&quot;: [
                {
                        &quot;collectionTime&quot;: 0,
                        &quot;name&quot;: &quot;PS Scavenge&quot;,
                        &quot;collectionCount&quot;: 0
                },
                {
                        &quot;collectionTime&quot;: 0,
                        &quot;name&quot;: &quot;PS MarkSweep&quot;,
                        &quot;collectionCount&quot;: 0
                }
        ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A list of all metrics and information corresponding to them can be found &lt;a href=&quot;https://gitlab.myteksi.net/olympus/iris/jvm-profiler/-/blob/master/metricDetails.md&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;sparkmeasure&quot;&gt;sparkMeasure&lt;/h4&gt;

&lt;p&gt;Complementing the JVM Profiler is sparkMeasure, a standalone tool that was built to robustly capture Spark job-specific metrics.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/iris/image7.png&quot; width=&quot;80%&quot; alt=&quot;&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt; Architecture of Spark Task Metrics, Listener Bus, and sparkMeasure (&lt;a href=&quot;https://github.com/LucaCanali/sparkMeasure&quot;&gt;Source&lt;/a&gt;)&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;It is registered as a custom listener and operates by collection built-in metrics that Spark exchanges between the driver node and executor nodes. Its standout feature is the ability to collect all metrics supported by Spark, as defined in Spark’s official documentation &lt;a href=&quot;https://spark.apache.org/docs/latest/monitoring.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Example stage metrics collected by sparkMeasure (&lt;a href=&quot;https://gitlab.myteksi.net/olympus/iris/sparkmeasure&quot;&gt;Source code&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Scheduling mode = FIFO

Spark Context default degree of parallelism = 8

Aggregated Spark stage metrics:

numStages =&amp;gt; 3
numTasks =&amp;gt; 17
elapsedTime =&amp;gt; 1291 (1 s)
stageDuration =&amp;gt; 1058 (1 s)
executorRunTime =&amp;gt; 2774 (3 s)
executorCpuTime =&amp;gt; 2004 (2 s)
executorDeserializeTime =&amp;gt; 2868 (3 s)
executorDeserializeCpuTime =&amp;gt; 1051 (1 s)
resultSerializationTime =&amp;gt; 5 (5 ms)
jvmGCTime =&amp;gt; 88 (88 ms)
shuffleFetchWaitTime =&amp;gt; 0 (0 ms)
shuffleWriteTime =&amp;gt; 16 (16 ms)
resultSize =&amp;gt; 16091 (15.0 KB)
diskBytesSpilled =&amp;gt; 0 (0 Bytes)
memoryBytesSpilled =&amp;gt; 0 (0 Bytes)
peakExecutionMemory =&amp;gt; 0
recordsRead =&amp;gt; 2000
bytesRead =&amp;gt; 0 (0 Bytes)
recordsWritten =&amp;gt; 0
bytesWritten =&amp;gt; 0 (0 Bytes)
shuffleRecordsRead =&amp;gt; 8
shuffleTotalBlocksFetched =&amp;gt; 8
shuffleLocalBlocksFetched =&amp;gt; 8
shuffleRemoteBlocksFetched =&amp;gt; 0
shuffleTotalBytesRead =&amp;gt; 472 (472 Bytes)
shuffleLocalBytesRead =&amp;gt; 472 (472 Bytes)
shuffleRemoteBytesRead =&amp;gt; 0 (0 Bytes)
shuffleRemoteBytesReadToDisk =&amp;gt; 0 (0 Bytes)
shuffleBytesWritten =&amp;gt; 472 (472 Bytes)
shuffleRecordsWritten =&amp;gt; 8

Stages and their duration:
Stage 0 duration =&amp;gt; 593 (0.6 s)
Stage 1 duration =&amp;gt; 416 (0.4 s)
Stage 3 duration =&amp;gt; 49 (49 ms)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;data-organisation&quot;&gt;Data organisation&lt;/h3&gt;

&lt;p&gt;The architecture of Iris is designed to efficiently route metrics to two key destinations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Real-time datasets: InfluxDB&lt;/li&gt;
  &lt;li&gt;Offline datasets: GrabTech Datalake in AWS&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;real-time-dataset&quot;&gt;Real-time dataset&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Freshness/latency&lt;/strong&gt;: 5 to 10 seconds&lt;/p&gt;

&lt;p&gt;All metrics flowing in through Kafka topics are instantly wired into InfluxDB. A crucial part of this process is accomplished by Telegraf, a plugin-driven server agent used for collecting and sending metrics. Acting as a Kafka consumer, Telegraf listens to each Kafka topic according to its corresponding metrics profiling. It parses the incoming JSON messages and extracts crucial data points (such as role, hostname, jobname, etc.). Once the data is processed, Telegraf writes it into the InfluxDB.&lt;/p&gt;

&lt;p&gt;InfluxDB organises the stored data in what we call ‘measurements’, which could analogously be considered as tables in traditional relational databases.&lt;/p&gt;

&lt;p&gt;In Iris’s context, we have structured our real-time data into the following crucial measurements:&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
  &lt;td&gt;
    &lt;ol&gt;
    &lt;li&gt;&lt;code&gt;CpuAndMemory&lt;/code&gt;: This measures CPU and memory-related metrics, giving us insights into resource utilisation by Spark jobs.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;I/O&lt;/code&gt;: This records input/output metrics, providing data on the reading and writing operations happening during the execution of jobs.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ThreadInfo&lt;/code&gt;: This measurement holds data related to job threading, allowing us to monitor concurrency and synchronisation aspects.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;application_started&lt;/code&gt; and &lt;code&gt;application_ended&lt;/code&gt;: These measurements allow us to track Spark application lifecycles, from initiation to completion.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;executors_started&lt;/code&gt; and &lt;code&gt;executors_removed&lt;/code&gt;: These measurements give us a look at the executor dynamics during Spark application execution.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/td&gt;
  &lt;td width=&quot;35%&quot;&gt;
  &lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
    &lt;img src=&quot;/img/iris/image3.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jobs_started&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jobs_ended&lt;/code&gt;: These provide vital data points relating to the lifecycle of individual Spark jobs within applications.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queries_started&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queries_ended&lt;/code&gt;: These measurements are designed to track the lifecycle of individual Spark SQL queries.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stage_metrics&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stages_started&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stages_ended&lt;/code&gt;: These measurements help monitor individual stages within Spark jobs, a valuable resource for tracking the job progress and identifying potential bottlenecks.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The real-time data collected in these measurements form the backbone of the monitoring capabilities of Iris, providing an accurate and current picture of Spark job performances.&lt;/p&gt;

&lt;h4 id=&quot;offline-dataset&quot;&gt;Offline dataset&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Freshness/latency&lt;/strong&gt;: 1 hour&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
  &lt;td&gt;
  In addition to real-time data management with InfluxDB, Iris is also responsible for routing metrics to our offline data storage in the Grab Tech Datalake for &lt;strong&gt;long-term trend&lt;/strong&gt; studies, &lt;strong&gt;pattern analysis&lt;/strong&gt;, and &lt;strong&gt;anomaly detection&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;
  The metrics from Kafka are periodically synchronised to the Amazon S3 tables under the &lt;code&gt;iris&lt;/code&gt; schema in the Grab Tech AWS catalogue. This valuable historical data from Kafka is meticulously organised with a one-to-one mapping between the platform or Kafka topic to the table in the iris schema. For example: &lt;code&gt;iris.chimera_jvmprofiler_cpuandmemory&lt;/code&gt; map with &lt;code&gt;prd-iris-chimera-jvmprofiler-cpuandmemory&lt;/code&gt; Kafka topic.
  &lt;/td&gt;
  &lt;td width=&quot;35%&quot;&gt;
  &lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
    &lt;img src=&quot;/img/iris/image1.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;This streamlined organisation means you can write queries to retrieve information from the AWS dataset very similarly to how you would do it from InfluxDB. Whether it’s CPU and memory usage, I/O, thread info, or spark metrics, you can conveniently fetch historical data for your analysis.&lt;/p&gt;

&lt;h3 id=&quot;data-visualisation&quot;&gt;Data visualisation&lt;/h3&gt;

&lt;p&gt;A well-designed visual representation makes it easier to see patterns, trends, and outliers in groups of data. Iris employs different visualisation tools based on whether the data is real-time or historical.&lt;/p&gt;

&lt;h4 id=&quot;real-time-data-visualisation---grafana&quot;&gt;Real-Time data visualisation - Grafana&lt;/h4&gt;

&lt;p&gt;Iris uses Grafana for showcasing real-time data. For each platform, two primary dashboards have been set up: JVM metrics and Spark metrics.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/iris/image11.png&quot; width=&quot;90%&quot; alt=&quot;&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;&lt;strong&gt;JVM metrics dashboard&lt;/strong&gt;: This dashboard is designed to display information related to the JVM.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/iris/image5.png&quot; width=&quot;90%&quot; alt=&quot;&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;&lt;strong&gt;Spark metrics dashboard&lt;/strong&gt;: This dashboard primarily focuses on visualising Spark-specific elements.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;h4 id=&quot;offline-data-visualisation&quot;&gt;Offline data visualisation&lt;/h4&gt;

&lt;p&gt;While real-time visualisation is crucial for immediate awareness and decision-making, visualising historical data provides invaluable insights about long-term trends, patterns, and anomalies. Developers can query the raw or aggregated data from the Iris tables for their specific analyses.&lt;/p&gt;

&lt;p&gt;Moreover, to assist platform owners and end-users in obtaining a quick summary of their job data, we provide built-in dashboards with pre-aggregated visuals. These dashboards contain a wealth of information expressed in an easy-to-understand format. Key metrics include:&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
  &lt;td&gt;
    &lt;li&gt;Total instances&lt;/li&gt;
    &lt;li&gt;Total CPU cores&lt;/li&gt;
    &lt;li&gt;Total memory&lt;/li&gt;
    &lt;li&gt;CPU and memory utilisation&lt;/li&gt;
    &lt;li&gt;Total machine runtimes&lt;/li&gt;
  &lt;/td&gt;
  &lt;td width=&quot;80%&quot;&gt;
  &lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
    &lt;img src=&quot;/img/iris/image13.png&quot; width=&quot;70%&quot; alt=&quot;&quot; /&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Besides visualisations for individual jobs, we have designed an overview dashboard providing a comprehensive summary of all resources consumed by all ETL jobs. This is particularly useful for platform owners and tech leads, allowing them to have an all-encompassing visibility of the performance and resource usage across the ETL jobs.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/iris/image15.png&quot; width=&quot;80%&quot; alt=&quot;&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Dashboard for monitoring ETL jobs&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;These dashboards’ visuals effectively turn the historical metrics data into clear, comprehensible, and insightful information, guiding users towards objective-driven decision-making.&lt;/p&gt;

&lt;h2 id=&quot;transforming-observations-into-insights&quot;&gt;Transforming observations into insights&lt;/h2&gt;

&lt;p&gt;While our journey with Iris is just in the early stages, we’ve already begun harnessing its ability to transform raw data into concrete insights. The strength of Iris lies not just in its data collection capabilities but also in its potential to analyse and infer patterns from the collated data.&lt;/p&gt;

&lt;p&gt;Currently, we’re experimenting with a &lt;strong&gt;job classification&lt;/strong&gt; model that aims to predict resource allocation efficiency (i.e. identifying jobs as over or under-provisioned). This information, once accurately predicted, can help optimise the usage of resources by fine-tuning the provisions for each job. While this model is still in its early stages of testing and lacks sufficient validation data, it exemplifies the direction we’re heading - integrating advanced analytics with operational observability.&lt;/p&gt;

&lt;p&gt;As we continue to refine Iris and develop more models, our aim is to empower users with deep insights into their Spark applications. These insights can potentially identify bottlenecks, optimise resource allocation and ultimately, enhance overall performance. In the long run, we see Iris evolving from being a data collection tool to a platform that can &lt;strong&gt;provide actionable recommendations&lt;/strong&gt; and &lt;strong&gt;enable data-driven decision-making&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;job-classification-feature-set&quot;&gt;Job classification feature set&lt;/h3&gt;

&lt;p&gt;At the core of our job classification model, there are two carefully selected metrics:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CPU cores per hour&lt;/strong&gt;: This represents the number of tasks a job can handle concurrently in a given hour. A higher number would mean more tasks being processed simultaneously.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Total Terabytes of data input per core&lt;/strong&gt;: This considers only the input from the underlying HDFS/S3 input, excluding shuffle data. It represents the volume of data one CPU core needs to process. A larger input would mean more CPUs are required to complete the job in a reasonable timeframe.&lt;img src=&quot;images/image2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The choice of these two metrics for building feature sets is based on a nuanced understanding of Spark job dynamics:&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
  &lt;td&gt;
    &lt;li&gt;Allocating the right CPU cores is crucial as a higher number of cores means more tasks being processed concurrently. This is especially important for jobs with larger input data and more partitioned files, as they often require more concurrent processing capacity, hence, more CPU cores.&lt;/li&gt;&lt;br /&gt;
    &lt;li&gt;The total data input helps to estimate the data processing load of a job. A job tasked with processing a high volume of input data but assigned low CPU cores might be under-provisioned and result in an extended runtime.&lt;/li&gt;
  &lt;/td&gt;
  &lt;td width=&quot;30%&quot;&gt;
  &lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
    &lt;img src=&quot;/img/iris/image2.png&quot; width=&quot;70%&quot; alt=&quot;&quot; /&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;As for CPU and memory utilisation, while it could offer useful insights, we’ve found it may not always contribute to predicting if a job is over or under-provisioned because utilisation can vary run-to-run. Thus, to keep our feature set robust and consistent, we primarily focus on CPU cores per hour and total terabytes of input data.&lt;/p&gt;

&lt;p&gt;With these metrics as our foundation, we are developing models that can classify jobs into over-provisioned or under-provisioned, helping us optimise resource allocation and improve job performance in the long run.&lt;/p&gt;

&lt;p&gt;As always, treat any information related to our job classification feature set and the insights derived from it with utmost care for data confidentiality and integrity.&lt;/p&gt;

&lt;p&gt;We’d like to reiterate that these models are still in the early stages of testing and we are constantly working to enhance their predictive accuracy. The true value of this model will be unlocked as it is refined and as we gather more validation data.&lt;/p&gt;

&lt;h3 id=&quot;model-training-and-optimisation&quot;&gt;Model training and optimisation&lt;/h3&gt;

&lt;p&gt;Choosing the right model is crucial for deriving meaningful insights from datasets. We decided to start with a simple, yet powerful algorithm - &lt;strong&gt;K-means clustering&lt;/strong&gt;, for job classification. K-means is a type of unsupervised machine learning algorithm used to classify items into groups (or clusters) based on their features.&lt;/p&gt;

&lt;p&gt;Here is our process:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Model exploration&lt;/strong&gt;: We began by exploring the K-means algorithm using a small dataset for validation.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Platform-specific cluster numbers&lt;/strong&gt;: To account for the uniqueness of every platform, we ran a Score Test (an evaluation method to determine the optimal number of clusters) for each platform. The derived optimal number of clusters is then used in the monthly job for that respective platform’s data.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Set up a scheduled job&lt;/strong&gt;: After ensuring the code was functioning correctly, we set up a job to run the model on a monthly schedule. Monthly re-training was chosen to encapsulate possible changes in the data patterns over time.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Model saving and utilisation&lt;/strong&gt;: The trained model is saved to our S3 bucket and used to classify jobs as over-provisioned or under-provisioned based on the daily job runs.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This iterative learning approach, through which our model learns from an ever-increasing pool of historical data, helps maintain its relevance and improve its accuracy over time.&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
  &lt;td&gt;
    Here is an example output from Databricks train run: &lt;br /&gt;
    &lt;li&gt;&lt;strong&gt;Blue green group&lt;/strong&gt;: Input per core is too large but the CPU per hour is small, so the job may take a lot of time to complete.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Purple group&lt;/strong&gt;: Input per core is too small but the CPU per hour is too high. There may be a lot of wasted CPU here.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Yellow group&lt;/strong&gt;: I think this is the ideal group where input per core and CPU per hour is not high.&lt;/li&gt;
  &lt;/td&gt;
  &lt;td width=&quot;45%&quot;&gt;
  &lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
    &lt;img src=&quot;/img/iris/image12.png&quot; width=&quot;70%&quot; alt=&quot;&quot; /&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Keep in mind that classification insights provided by our K-means model are still in the experimental stage. As we continue to refine the approach, the reliability of these insights is expected to grow, providing increasingly valuable direction for resource allocation optimisation.&lt;/p&gt;

&lt;h2 id=&quot;seeing-iris-in-action&quot;&gt;Seeing Iris in action&lt;/h2&gt;

&lt;p&gt;This section provides practical examples and real-case scenarios that demonstrate Iris’s capacity for delivering insights from ETL job observations.&lt;/p&gt;

&lt;h3 id=&quot;case-study-1-spark-benchmarking&quot;&gt;Case study 1: Spark benchmarking&lt;/h3&gt;

&lt;p&gt;From August to September 2023, we carried out a Spark benchmarking exercise to measure and compare the cost and performance of Grab’s Spark platforms: Open Source Spark on Kubernetes (Chimera), Databricks and AWS EMR. Since each platform has its own way to measure a job’s performance and cost, Iris was used to collect the necessary Spark metrics in order to calculate the cost for each job. Furthermore, many other metrics were collected by Iris in order to compare the platforms’ performances like CPU and memory utilisation, runtime, etc.&lt;/p&gt;

&lt;h3 id=&quot;case-study-2-improving-databricks-infra-cost-unit-dbiu-accuracy-with-iris&quot;&gt;Case study 2: Improving Databricks Infra Cost Unit (DBIU) Accuracy with Iris&lt;/h3&gt;

&lt;p&gt;Being able to accurately calculate and fairly distribute Databricks infrastructure costs has always been a challenge, primarily due to difficulties in distinguishing between on-demand and Spot instance usage. This was further complicated by two conditions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Fallback to on-demand instances&lt;/strong&gt;: Databricks has a feature that automatically falls back to on-demand instances when Spot instances are not readily available. While beneficial for job execution, this feature has traditionally made it difficult to accurately track per-job Spot vs. on-demand usage.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;User configurable hybrid policy&lt;/strong&gt;: Users can specify a mix of on-demand and Spot instances for their jobs. This flexible, hybrid approach often results in complex, non-uniform usage patterns, further complicating cost categorisation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Iris has made a key difference in resolving these dilemmas. By providing granular, instance-level metrics including whether each instance is on-demand or Spot, Iris has greatly &lt;strong&gt;improved our visibility into per-job instance usage&lt;/strong&gt;.&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
  &lt;td&gt;
    This precise data enables us to isolate the on-demand instance usage, which was previously bundled in the total cost calculation. Similarly, it allows us to accurately gauge and consider the usage ratio of on-demand instances in hybrid policy scenarios.
  &lt;/td&gt;
  &lt;td width=&quot;60%&quot;&gt;
  &lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
    &lt;img src=&quot;/img/iris/image6.png&quot; width=&quot;70%&quot; alt=&quot;&quot; /&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The enhanced transparency provided by Iris metrics allows us to standardise DBIU cost calculations, making them fairer for users who majorly or only use Spot instances. In other words, users need to pay more if they intentionally choose or fall back to on-demand instances for their jobs.&lt;/p&gt;

&lt;p&gt;The practical application of Iris in enhancing DBIU accuracy illustrates its potential in driving data-informed decisions and fostering fairness in resource usage and cost distribution.&lt;/p&gt;

&lt;h3 id=&quot;case-study-3-optimising-job-configuration-for-better-performance-and-cost-efficiency&quot;&gt;Case study 3: Optimising job configuration for better performance and cost efficiency&lt;/h3&gt;

&lt;p&gt;One of the key utilities of iris is its potential to assist with job optimisation. For instance, we have been able to pinpoint jobs that were consistently over-provisioned and work with end-users to tune their job configurations.&lt;/p&gt;

&lt;p&gt;Through this exercise and continuous monitoring, we’ve seen substantial results from the job optimisations:&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
  &lt;td&gt;
    &lt;li&gt;Cost reductions ranging from &lt;strong&gt;20%&lt;/strong&gt; to &lt;strong&gt;50%&lt;/strong&gt; for most jobs.&lt;/li&gt;
    &lt;li&gt;Positive feedback from users about improvements in job performance and cost efficiency.&lt;/li&gt;
  &lt;/td&gt;
  &lt;td width=&quot;50%&quot;&gt;
  &lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
    &lt;img src=&quot;/img/iris/image4.png&quot; width=&quot;70%&quot; alt=&quot;&quot; /&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;By the way, interestingly, our analysis led us to identify certain the following patterns. These patterns could be leveraged to widen the impact of our optimisation efforts across multiple use-cases in our platforms:&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
   &lt;thead&gt;
   &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Pattern&lt;/strong&gt;
      &lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Recommendation&lt;/strong&gt;
      &lt;/th&gt;
   &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
      &lt;td width=&quot;50%&quot;&gt;
      &lt;li&gt;Job duration &amp;lt; 20 minutes&lt;/li&gt;
      &lt;li&gt;Input per core &amp;lt; 1GB&lt;/li&gt;
      &lt;li&gt;Total used instance is 2x/3x of max worker nodes&lt;/li&gt;
      &lt;/td&gt;
      &lt;td&gt;&lt;li&gt;Use fixed number of workers nodes potentially speeding up performance and certainly reducing costs.&lt;/li&gt;
      &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;&lt;li&gt;CPU utilisation &amp;lt; 25% &lt;/li&gt;
      &lt;/td&gt;
      &lt;td&gt;
      &lt;li&gt;Cut max worker in half. E.g: 10 to 5 workers&lt;/li&gt;
      &lt;li&gt;Downgrade instance size a half. E.g: 4xlarge -&amp;gt; 2xlarge&lt;/li&gt;
      &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;&lt;li&gt;Job has much shuffle&lt;/li&gt;
      &lt;/td&gt;
      &lt;td&gt;&lt;li&gt;Bump the instance size and reduce the number of workers. E.g. bump 2xlarge -&amp;gt; 4xlarge and reduce number of workers from 100 -&amp;gt; 50&lt;/li&gt;
      &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;However, we acknowledge that these findings may not apply uniformly to every instance. The optimisation recommendations derived from these patterns might not yield the desired outcomes in all cases.&lt;/p&gt;

&lt;h2 id=&quot;the-future-of-iris&quot;&gt;The future of Iris&lt;/h2&gt;

&lt;p&gt;Building upon its firm foundation as a robust Spark observability tool, we envision a future for Iris wherein it not only monitors metrics but provides actionable insights, discerns usage patterns, and drives predictions.&lt;/p&gt;

&lt;p&gt;Our plans to make Iris more accessible include developing &lt;strong&gt;APIs endpoint&lt;/strong&gt; for platform teams to query performance by job names. Another addition we’re aiming for is the ability for Iris to provide resource tuning recommendations. By making platform-specific and job-specific recommendations easily accessible, we hope to assist platform teams in making informed, data-driven decisions on resource allocation and cost efficiency.&lt;/p&gt;

&lt;p&gt;We’re also looking to expand Iris’s capabilities with the development of a &lt;strong&gt;listener&lt;/strong&gt; for &lt;strong&gt;Presto jobs&lt;/strong&gt;, similar to the sparkMeasure tool currently used for Spark jobs. The listener would provide valuable metrics and insights into the performance of Presto jobs, opening up new avenues for optimisation and cost management.&lt;/p&gt;

&lt;p&gt;Another major focus will be &lt;strong&gt;building a feedback loop&lt;/strong&gt; for Iris to further enhance accuracy, continually refine its models, and improve insights provided. This effort would greatly benefit from the close collaboration and inputs from platform teams and other tech leads, as their expertise aids in interpreting Iris’s metrics and predictions and validating its meaningfulness.&lt;/p&gt;

&lt;p&gt;In conclusion, as Iris continues to develop and mature, we foresee it evolving into a crucial tool for data-driven decision-making and proactive management of Spark applications, playing a significant role in the efficient usage of cloud computing resources.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The role of Iris as an observability tool for Spark jobs in the world of Big Data is rapidly evolving. Iris has proven to be more than a simple data collection tool; it is a platform that integrates advanced analytics with operational observability.&lt;/p&gt;

&lt;p&gt;Even though Iris is in its early stages, it’s already been instrumental in creating detailed visualisations of both real-time and historical data from varied platforms. Besides that, Iris has started making strides in its journey towards using machine learning models like K-means clustering to classify jobs, demonstrating its potential in helping operators fine-tune resource allocation.&lt;/p&gt;

&lt;p&gt;Using instance-level metrics, Iris is helping improve cost distribution fairness and accuracy, making it a potent tool for resource optimisation. Furthermore, the successful case study of reducing job costs and enhancing performance through resource reallocation provides a promising outlook into Iris’s future applicability.&lt;/p&gt;

&lt;p&gt;With ongoing development plans, such as the Presto listener and the creation of endpoints for broader accessibility, Iris is poised to become an integral tool for data-informed decision-making. As we strive to enhance Iris, we will continue to collaborate with platform teams and tech leads whose feedback is invaluable in fulfilling Iris’s potential.&lt;/p&gt;

&lt;p&gt;Our journey with Iris is a testament to Grab’s commitment to creating a data-informed and efficient cloud computing environment. Iris, with its observed and planned capabilities, is on its way to revolutionising the way resource allocation is managed and optimised.&lt;/p&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Wed, 03 Apr 2024 01:13:10 +0000</pubDate>
        <link>https://engineering.grab.com/iris</link>
        <guid isPermaLink="true">https://engineering.grab.com/iris</guid>
        
        <category>Data insights</category>
        
        <category>Metrics</category>
        
        <category>Decision making</category>
        
        <category>Analytics</category>
        
        
        <category>Engineering</category>
        
        <category>Data Science</category>
        
      </item>
    
      <item>
        <title>Android App Size at Scale with Project Bonsai</title>
        <description>&lt;p&gt;Grab is Southeast Asia’s leading superapp, providing a suite of services that brings essential needs to users throughout the region. Its offerings include ride-hailing, food delivery, parcel delivery, mobile payments, and more. With safety, efficiency, and user-centered design at heart, Grab remains dedicated to solving everyday issues and improving the lives of millions.&lt;/p&gt;

&lt;p&gt;As the app continues to expand with more features, Grab identified the need for a consistent, high-quality experience for new users who may have limited storage space or restricted internet bandwidth. Read to find out more about Project Bonsai and how it reduced app download size and app disk size.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In 2020, Google conducted research that highlighted the &lt;a href=&quot;https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2&quot;&gt;negative impact of app sizes on conversion rates&lt;/a&gt;, revealing a 1% decrease for every 6MB expansion of the app APK size. This finding prompted Grab to ensure new and existing users had a consistently excellent &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.grabtaxi.passenger&quot;&gt;Grab superapp&lt;/a&gt; experience, given the prevalence of low-end devices and disparate internet infrastructure in Southeast Asian regions. As a result, Grab initiated &lt;strong&gt;Project Bonsai&lt;/strong&gt; in Q3 2021, with the goal of reducing and optimising the app size while enhancing user experience, reducing installation barriers, and boosting user acquisition.&lt;/p&gt;

&lt;h3 id=&quot;understanding-the-problem&quot;&gt;Understanding the problem&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.grabtaxi.passenger&quot;&gt;Grab superapp&lt;/a&gt;, with over 4 million lines of code and integration with hundreds of third-party libraries, had a significant app size. Given the prevalence of low-end devices and disparate internet infrastructure in our target region, it is crucial for us to proactively and constantly ensure we are delivering excellence in app-based user experience.&lt;/p&gt;

&lt;h3 id=&quot;objectives-of-the-bonsai-project&quot;&gt;Objectives of the Bonsai project&lt;/h3&gt;

&lt;p&gt;The Bonsai project focused on these two key metrics:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;App Download Size&lt;/strong&gt;: This represents the total size of the compressed APK file that users need to download from Google Play when performing a fresh installation.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;App Disk Size&lt;/strong&gt;: This encompasses the total storage space occupied by the app on user devices, including both the binary and data generated by the app.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this article, we will share the strategy and solutions that resulted in a successful &lt;strong&gt;26% reduction in App Download Size&lt;/strong&gt;, while also reducing the App Disk Size.&lt;/p&gt;

&lt;h3 id=&quot;status-quo&quot;&gt;Status quo&lt;/h3&gt;

&lt;p&gt;Prior to the Bonsai project, the Grab app project had implemented various measures to achieve optimal app size. Here are some notable highlights:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Leveraging App Bundle&lt;/strong&gt;: Since 2019, Grab has been using the app bundle approach to optimise app delivery. This approach generates smaller APKs tailored to specific device configurations, ensuring users receive optimised APKs. This helps reduce the overall app size and improve installation efficiency.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Monitoring&lt;/strong&gt;: With a team of over 100 Android engineers and multiple collaborative teams, the Grab app undergoes a weekly release process involving hundreds of commits for each release. Closely monitoring app size changes with every commit is essential for our team. The team established debug build (APK file size) monitoring for &lt;strong&gt;every commit merged to the master branch&lt;/strong&gt;. Regular weekly reviews are conducted to stay updated on the app size and identify commits that might lead to changes in app size. However, occasional mismatches may occur due to discrepancies between the debug and release builds.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/project-bonsai/image1.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Monitoring the changes in APK size&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;R8 Integration&lt;/strong&gt;: R8/Proguard, known as the code shrinker, obfuscator, and optimiser, has been enabled since the beginning. This powerful tool helps reduce the app’s bytecode and resources, leading to further size optimisation and improved app performance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Resource Optimisation&lt;/strong&gt;: The team diligently pursued resource optimisation strategies, including:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Images: Engineers were encouraged to use vector images whenever possible, as they usually have smaller file sizes than raster images. In exceptional cases where raster images were necessary, Grab adopted the webp format instead of png, utilising better image compression to minimise app size.&lt;/li&gt;
      &lt;li&gt;Language ResourceConfig: Grab enabled resourceConfig to support only the languages actively used by the Grab app, reducing unnecessary resource overhead and enhancing app efficiency.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Third-Party Libraries Review&lt;/strong&gt;: The team established a review process for third-party libraries, assessing their size impact on the app. This practice ensured that only essential libraries were included, preventing unnecessary bloating of the app size.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Despite the application of these measures and solutions aimed at managing the app size, there was still the potential of significant expansion in magnitude.&lt;/p&gt;

&lt;h2 id=&quot;strategy&quot;&gt;Strategy&lt;/h2&gt;

&lt;p&gt;The Bonsai project revolves around strategic pillars, namely Measurement, Reduction, and Containment.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/project-bonsai/image7.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Project Bonsai&apos;s three strategic pillars for continuous app size reduction&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;In the &lt;strong&gt;Measurement&lt;/strong&gt; phase, the focus is on providing accurate information on the app’s binary composition and how individual features, modules, libraries impact the overall app size. This allows teams to make informed decisions and gain insights into their components’ influence on the app’s size.&lt;/p&gt;

&lt;p&gt;The insights from the Measure phase provided us with a list of actionable items for our backlog. In the &lt;strong&gt;Reduction&lt;/strong&gt; phase, we employ strategic action to tackle this backlog to constantly achieve optimal app size.&lt;/p&gt;

&lt;p&gt;Optimising the app size is not a one-time endeavour, especially as more features are added over time, potentially increasing the project’s size. While there may be limited solutions to manage app size, it’s important to find a balance between size and functionality. Else, the effort and trade-offs required may become overwhelming. Therefore, in the &lt;strong&gt;Containment&lt;/strong&gt; phase, we intend to introduce effective long-term strategies and solutions designed to manage the app’s size.&lt;/p&gt;

&lt;p&gt;In the remainder of this blog post, we explore the strategic pillars and actions taken to contain the download size.&lt;/p&gt;

&lt;h3 id=&quot;measure&quot;&gt;Measure&lt;/h3&gt;

&lt;p&gt;The Grab Passenger App Core team actively engages in optimisation projects and recognised the importance of measurement as the foundation for improvement. For example, enhancing the app startup time, pipeline time, build time, and more.&lt;/p&gt;

&lt;p&gt;In every optimisation endeavour, we adhere to a crucial principle: “MEASURE” - the first and most critical step for any improvement project. As the famous quote goes, “If you can’t measure it, you can’t improve it.” This emphasises the significance of accurate and comprehensive measurement as the foundation for driving successful optimisation efforts.&lt;/p&gt;

&lt;p&gt;In the third quarter of 2021, our team initiated an investigation into existing tools provided by both Google and the broader community. The intention was to employ tools such as &lt;a href=&quot;https://developer.android.com/tools/apkanalyzer&quot;&gt;APK Analyzer&lt;/a&gt; or Android Studio to conduct a thorough analysis of the app binary. However, it soon became evident that these tools were not well-suited to accommodate the extensive scope of our project.&lt;/p&gt;

&lt;p&gt;In order to accommodate our discovery, we developed a custom analytics tool called App Sizer. This tool is specifically designed to analyse app binaries from bundle files. Our primary goal was to construct a solution that adheres effectively to our unique needs.&lt;/p&gt;

&lt;p&gt;The tool was seamlessly integrated into Grab’s CI system and sends data to a &lt;a href=&quot;https://grafana.com/&quot;&gt;Grafana&lt;/a&gt; instance. As a result, the tool collates and transmits daily analytics data from the release candidate branch. It offers the following key functionalities and monitors important aspects such as:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Device-specific App Download Size&lt;/strong&gt;: Precise information about the app download size for specific devices, focusing on optimising the App Download Size.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/project-bonsai/image3.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Trends for app download size by device type&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Comprehensive Size Breakdown&lt;/strong&gt;: A breakdown of the app’s size, including the proportion attributed to the codebase Kotlin/Java, Kotlin/Java-based libraries, native libraries, resources, and other relevant factors.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/project-bonsai/image6.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Comprehensive breakdown of app download size by component&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Size Contribution by Teams&lt;/strong&gt;: Insights into the size contributed by each individual team within the project’s scope.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/project-bonsai/image5.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Breakdown of Grab&apos;s codebase by TF&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Module-wise Size Contribution&lt;/strong&gt;: Insights into the size impacted by each module, categorised by team.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/project-bonsai/image8.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Breakdown of the codebase by TF modules&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Size Contribution by Third-Party Libraries&lt;/strong&gt;: Information about the size attributed to each third-party library incorporated within the app.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/project-bonsai/image2.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;App download size contribution by external libraries and SDK breakdown&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;List of Large Files&lt;/strong&gt;: A categorised list of large files (file size exceeding X value), organised by each respective team.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/project-bonsai/image4.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Large file categories broken down by TF&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;It’s important to note that all the size values presented within these dashboards specifically pertain to the download size, representing the contribution of each item to the overall app download size.&lt;/p&gt;

&lt;p&gt;As part of our commitment to the developer community, we plan to open-source this tool in the near future, allowing others to benefit from its capabilities as well.&lt;/p&gt;

&lt;h3 id=&quot;reduce&quot;&gt;Reduce&lt;/h3&gt;

&lt;p&gt;To optimise the app based on the analysis data obtained from the measuring step, we focused on applying common solutions from Google and the suggestions from the community. There were no fancy solutions that we invented. Our concentration centered on optimising the &lt;a href=&quot;https://source.android.com/docs/core/runtime/dex-format&quot;&gt;dex file&lt;/a&gt; size, refining resources, and eliminating duplication and redundancy.&lt;/p&gt;

&lt;h4 id=&quot;dex-file-optimisation-javakotlin&quot;&gt;dex file optimisation (Java/Kotlin)&lt;/h4&gt;

&lt;p&gt;In our initial findings, it became evident that Java/Kotlin code was the major contributor of app size. Recognising this, we made it our top priority for optimisation.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;R classes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;During our investigation, we discovered that a proportion of the overall app size was attributable to R classes. Further research unveiled two primary reasons behind this phenomenon:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mobileit.cz/Blog/Pages/r-class.aspx&quot;&gt;Transitive R classes&lt;/a&gt;: R classes contained ID references not only to their own resources but also to resources from their transitive dependencies. This meant that if Module A depended on Module B, and Module B in turn, depended on Module C (Module A -&amp;gt; Module B -&amp;gt; Module C), then Module A’s R class included IDs references to resources from Modules B and C, even if Module A didn’t directly utilise these resources. This explained why R classes in a modularised project could accumulate millions of lines of code.&lt;/li&gt;
  &lt;li&gt;A spread of Modules and Third-Party Libraries: Our Grab project comprised over 1,500 modules and integrates hundreds of third-party libraries, leading to the generation of significantly large R classes within the project. Furthermore, this discovery also explained instances where our app size monitor exhibited spikes during certain commits despite no significant additions of resources, libraries, or code within those commits. These fluctuations were linked to changes in the dependency graph, further emphasising the impact of Transitive R classes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It is worth noting that the team had long been cognisant of the challenges posed by Transitive R classes, especially in terms of optimising build times. Consequently, we had already undertaken various initiatives to address this specific challenge related to build times.&lt;/p&gt;

&lt;p&gt;However, it wasn’t long before we started wondering why R8 wasn’t removing unused fields from the R classes, which would have resulted in a size reduction for these classes. It turned out that back in mid-2021, we were using Android Gradle Plugin 4.0 along with the default R8 rules. One of these rules was preserving all fields in the R classes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-keepclassmembers class **.R$* {

   public static &amp;lt;fields&amp;gt;;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This rule was the root cause of why unused fields in the R classes were persisting. Google removed this &lt;a href=&quot;https://issuetracker.google.com/issues/142449264&quot;&gt;rule in AGP 4.1&lt;/a&gt;, and the solution was straightforward: updating AGP to version 4.1.1 (or newer) helped us resolve the issue.&lt;/p&gt;

&lt;p&gt;However, due to the project’s unusual size, there was a risk of inadvertently removing non-used R class fields if there were any instances of code accessing R classes through reflection within the codebase or third-party libraries. Since our automation testing did not yet support R8, conducting a full test of the entire project was possible, but would have demanded significant effort from the team. To avoid this substantial effort, we developed a script to search the entire codebase and identify instances where reflections were used, allowing us to assess their usage. For third-party libraries, we decompiled the libraries and applied the same script to the decompiled code.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Fix &amp;amp; Optimise R8 Rules&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Subsequently, we conducted a revision of the R8 configuration rules. This involved assessing the compiled R8 configuration file and paying specific attention to any ‘keep’ rules that contained package wildcards. It is crucial to decipher the purpose behind each rule and its reason for existence. Any rules identified as redundant were recommended for removal. Post the thorough scrutiny of the R8 rules, we initiated request tickets urging the respective teams to work on the elimination and optimisation of these rules.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Enable more aggressive optimisations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In 2019, Google began recommending the utilisation of the &lt;a href=&quot;https://android.googlesource.com/platform/sdk/%2B/master/files/proguard-android-optimize.txt&quot;&gt;proguard-android-optimise.txt&lt;/a&gt; configuration with code optimisation enabled. However, our project’s origins predate the introduction of Google’s R8, a time when Proguard was the primary tool for code obfuscation and size reduction. Prior to the release of Android Gradle Plugin 3.4.0, there were no explicit recommendations for enabling code optimisations during the minification process. As a result, our project has persisted in using the &lt;a href=&quot;https://android.googlesource.com/platform/sdk/%2B/master/files/proguard-android.txt&quot;&gt;proguard-android.txt&lt;/a&gt; configuration without activating the code optimisation feature.&lt;/p&gt;

&lt;p&gt;Our team has considered adopting a more aggressive approach towards optimisation. This approach spans from exploring the &lt;a href=&quot;https://android.googlesource.com/platform/sdk/%2B/master/files/proguard-android-optimize.txt&quot;&gt;optimisation mode&lt;/a&gt; to incorporating the &lt;a href=&quot;https://developer.android.com/build/shrink-code&quot;&gt;R8 full mode&lt;/a&gt;. This includes substantial effort required for testing and addressing issues arising from the introduction of these new modes. We encountered a particular challenge wherein the R8 optimisation exhibits instability, an issue that has been &lt;a href=&quot;https://issuetracker.google.com/u/1/issues/240077160&quot;&gt;reported to Google&lt;/a&gt;. A definitive solution remains a work-in-progress.&lt;/p&gt;

&lt;p&gt;At present, we have decided to postpone the implementation of a more aggressive R8 mode. However, this remains a high-priority item on our agenda, and we intend to address it in the near future.&lt;/p&gt;

&lt;h4 id=&quot;resources-optimisation&quot;&gt;Resources optimisation&lt;/h4&gt;

&lt;p&gt;In addition to optimising the dex file, we also address resource optimisation.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Handling large resources&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;During the Measure phase, we use the List Of Large Files dashboard to identify large files categorised by teams. For each team, we create request tickets with straightforward guidance. These guidelines encourage the following actions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Explore the possibility of removing unnecessary resources.&lt;/li&gt;
  &lt;li&gt;Consider offloading the resource to the Internet (server) when feasible. Within Grab, we have the Asset Delivery Kit, which facilitates hosting and downloading resources on the client side.&lt;/li&gt;
  &lt;li&gt;Optimise files by converting them to alternative formats or reducing their size. For instance, for images, we recommend utilising vector images and the Webp format, among other optimisations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Convert PNG to Webp&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Grab app project has a long history, and while the team has recently established guidelines and implemented CI processes to promote the use of vector and Webp images, there are still existing images that have not been optimised. The team has undertaken an initiative to address these images and has converted all PNG images to Webp format wherever a reduction in file size is achievable.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Fonts&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Fonts are another group of files that have a notable impact on the project’s size. We collaborate with the teams to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Remove fonts that are rarely used in the project.&lt;/li&gt;
  &lt;li&gt;Eliminate duplicate fonts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While the project still contains numerous fonts, we have a project to unify all features and transition to using a single font. Our recommendation is to explore the use of one primary font style, with the flexibility to incorporate different &lt;a href=&quot;https://developer.android.com/reference/android/graphics/Typeface&quot;&gt;typeface variations&lt;/a&gt; in your programming to achieve various typefaces using the same font.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Remove stale features and replace large library&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Based on the data, it was discovered that a specific library, which was contributing approximately 8% to the overall app size, had an adverse impact. This library has since been removed from the project. Moreover, through analysing the Size Contribution by Third-Party Libraries dashboard, we identified duplicates in functions and have made efforts to eliminate these redundancies.&lt;/p&gt;

&lt;p&gt;Moreover, in Grab, we are using the feature toggle to enable or disable a feature. The feature flags are controlled remotely. It’s very useful for running an experiment or turning off if a feature causes us any problems. So, many features in the project are controlled under a feature flag. In certain cases, even when some features are deactivated, the corresponding code remains included in the binary. We identify these cases and collaborate with teams to remove the redundant code.&lt;/p&gt;

&lt;p&gt;After six months of working on the above initiatives, the Bonsai team managed to reduce the Grab app download size by &lt;strong&gt;26%&lt;/strong&gt;. This is particularly noteworthy, considering that prior to the commencement of the Bonsai Project, the average app size exhibited a monthly increase of approximately 1%.&lt;/p&gt;

&lt;h3 id=&quot;containment&quot;&gt;Containment&lt;/h3&gt;

&lt;p&gt;After dedicating over a semester to the Reduce phase, we started the transition to the Containment phase. The first step for this phase involved setting up an App Growth Rate dashboard that presents the growth rate of app download size per release. Our goal is to keep this rate as low as possible.&lt;/p&gt;

&lt;p&gt;The team has been discovering a few solutions, such as introducing the common UI design components to prevent duplication, and experimenting with &lt;a href=&quot;https://developer.android.com/guide/playcore/feature-delivery&quot;&gt;Dynamic Delivery Feature&lt;/a&gt;. This phase of exploration is still ongoing and we are optimistic that it will help maintain a manageable app download size, or perhaps even contribute to further optimization.&lt;/p&gt;

&lt;p&gt;Considering alternative initiatives, the team is contemplating recognising app size as a confined resource of our application. We believe it should be the responsibility of every team to maintain an optimal app size. Based on the measurements we have, which provide an insight into each team’s impact on the total app download size, it could be advantageous to allocate an ‘app size budget’ to each team. This would entail each team taking responsibility for managing and maintaining the size influenced by their work.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Grab’s Project Bonsai demonstrated the company’s commitment to optimising the app experience for users in Southeast Asia. By prioritising code optimisation, resource management, modularisation, and asset bundling, we achieved substantial optimisations in app size while enhancing user experience. These efforts not only addressed the challenges we outlined, but also contributed to increased user acquisition and improved user retention rates.&lt;/p&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Mar 2024 02:22:10 +0000</pubDate>
        <link>https://engineering.grab.com/project-bonsai</link>
        <guid isPermaLink="true">https://engineering.grab.com/project-bonsai</guid>
        
        <category>App size</category>
        
        <category>Optimisation</category>
        
        <category>Project Bonsai</category>
        
        <category>App download size</category>
        
        <category>App disk size</category>
        
        <category>Scalability</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>Enabling near real-time data analytics on the data lake</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the domain of data processing, data analysts run their ad hoc queries on the data lake. The lake serves as an interface between our analytics and production environment, preventing downstream queries from impacting upstream data ingestion pipelines. To ensure efficient data processing in the data lake, choosing appropriate storage formats is crucial.&lt;/p&gt;

&lt;p&gt;The vanilla data lake solution is built on top of cloud object storage with Hive metastore, where data files are written in Parquet format. Although this setup is optimised for scalable analytics query patterns, it struggles to handle frequent updates to the data due to two reasons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The Hive table format requires us to rewrite the Parquet files with the latest data. For instance, to update one record in a Hive unpartitioned table, we would need to read all the data, update the record, and write back the entire data set.&lt;/li&gt;
  &lt;li&gt;Writing Parquet files is expensive due to the overhead of organising the data to a compressed columnar format, which is more complex than a row format.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The issue is further exacerbated by the scheduled downstream transformations. These necessary steps, which clean and process the data for use, increase the latency because the total delay now includes the combined scheduled intervals of these processing jobs.&lt;/p&gt;

&lt;p&gt;Fortunately, the introduction of the Hudi format, which supports fast writes by allowing Avro and Parquet files to co-exist on a Merge On Read (MOR) table, opens up the possibility of having a data lake with minimal data latency. The concept of a commit timeline further allows data to be served with Atomicity, Consistency, Isolation, and Durability (ACID) guarantees.&lt;/p&gt;

&lt;p&gt;We employ different sets of configurations for the different characteristics of our input sources:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;High or low throughput.&lt;/strong&gt; A high-throughput source refers to one that has a high level of activity. One example of this can be our stream of booking events generated from each customer transaction. On the other hand, a low-throughput source would be one that has a relative low level of activity. An example of this can be transaction events generated from reconciliation happening on a nightly basis.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Kafka (unbounded) or Relational Database Sources (bounded).&lt;/strong&gt; Our sinks have sources that can be broadly categorised into unbounded and bounded sources. Unbounded sources are usually related to transaction events materialised as Kafka topics, representing user-generated events as they interact with the Grab superapp. Bounded sources usually refer to Relational Database (RDS) sources, whose size is bound to storage provisioned.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following sections will delve into the differences between each source and our corresponding configurations optimised for them.&lt;/p&gt;

&lt;h2 id=&quot;high-throughput-source&quot;&gt;High throughput source&lt;/h2&gt;

&lt;p&gt;For our data sources with high throughput, we have chosen to write the files in MOR format since the writing of files in Avro format allows for fast writes to meet our latency requirements.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/near-realtime-data-analytics/image2.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Figure 1 Architecture for MOR tables&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;As seen in Figure 1, we use Flink to perform the stream processing and write out log files in Avro format in our setup. We then set up a separate Spark writer which periodically converts the Avro files into Parquet format in the Hudi &lt;a href=&quot;https://hudi.apache.org/docs/next/compaction&quot;&gt;compaction process&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have further simplified the coordination between the Flink and Spark writers by enabling asynchronous services on the Flink writer so it can generate the compaction plans for Spark writers to act on. During the Spark job runs, it checks for available compaction plans and acts on them, placing the burden of orchestrating the writes solely on the Flink writer. This approach could help minimise potential concurrency problems that might otherwise arise, as there would be a single actor
orchestrating the associated Hudi table services.&lt;/p&gt;

&lt;h2 id=&quot;low-throughput-source&quot;&gt;Low throughput source&lt;/h2&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/near-realtime-data-analytics/image1.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Figure 2 Architecture for COW tables&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;For low throughput sources, we gravitate towards the choice of Copy On Write (COW) tables given the simplicity of its design, since it only involves one component, which is the Flink writer. The downside is that it has higher data latency because this setup only generates Parquet format data snapshots at each checkpoint interval, which is typically about 10-15 minutes.&lt;/p&gt;

&lt;h2 id=&quot;connecting-to-our-kafka-unbounded-data-source&quot;&gt;Connecting to our Kafka (unbounded) data source&lt;/h2&gt;

&lt;p&gt;Grab uses Protobuf as our central data format in Kafka, ensuring schema evolution compatibility. However, the derivation of the schema of these topics still requires some transformation to make it compatible with Hudi’s accepted schema. Some of these transformations include ensuring that Avro record fields do not contain just a single array field, and handling logical decimal schemas to transform them to fixed byte schema for Spark compatibility.&lt;/p&gt;

&lt;p&gt;Given the unbounded nature of the source, we decided to partition it by Kafka event time up to the hour level. This ensured that our Hudi operations would be faster. Parquet file writes would be faster since they would only affect files within the same partition, and each Parquet file within the same event time partition would have a bounded size given the monotonically increasing nature of Kafka event time.&lt;/p&gt;

&lt;p&gt;By partitioning tables by Kafka event time, we can further optimise compaction planning operations, since the amount of file lookups required is now reduced with the use of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BoundedPartitionAwareCompactionStrategy&lt;/code&gt;. Only log files in recent partitions would be selected for compaction and the job manager need not list every partition to figure out which log files to select for compaction during the planning phase anymore.&lt;/p&gt;

&lt;h2 id=&quot;connecting-to-our-rds-bounded-data-source&quot;&gt;Connecting to our RDS (bounded) data source&lt;/h2&gt;

&lt;p&gt;For our RDS, we decided to use the Flink Change Data Capture (CDC) connectors by Veverica to obtain the binlog streams. The RDS would then treat the Flink writer as a replication server and start streaming its binlog data to it for each MySQL change. The Flink CDC connector presents the data as a Kafka Connect (KC) Source record, since it uses the Debezium connector under the hood. It is then a straightforward task to deserialise these records and transform them into Hudi records, since
the Avro schema and associated data changes are already captured within the KC source record.&lt;/p&gt;

&lt;p&gt;The obtained binlog timestamp is also emitted as a metric during consumption for us to monitor the observed data latency at the point of ingestion.&lt;/p&gt;

&lt;p&gt;Optimising for these sources involves two phases:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First, assigning more resources for the cold start incremental snapshot process where Flink takes a snapshot of the current data state in the RDS and loads the Hudi table with that snapshot. This phase is usually resource-heavy as there are a lot of file writes and data ingested during this process.&lt;/li&gt;
  &lt;li&gt;Once the snapshotting is completed, Flink would then start to process the binlog stream and the observed throughput would drop to a level similar to the DB write throughput. The resources required by the Flink writer at this stage would be much lower than in the snapshot phase.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;indexing-for-hudi-tables&quot;&gt;Indexing for Hudi tables&lt;/h2&gt;

&lt;p&gt;Indexing is important for upserting Hudi tables when the writing engine performs updates, allowing it to efficiently locate the file groups of the data to be updated.&lt;/p&gt;

&lt;p&gt;As of version 0.14, the Flink engine only supports Bucket Index or Flink State Index. Bucket Index performs indexing of the file record by hashing the record key and matching it to a specific bucket of files indicated by the naming convention of the written data files. Flink State Index on the other hand stores the index map of record keys to files in memory.&lt;/p&gt;

&lt;p&gt;Given that our tables include unbounded Kafka sources, there is a possibility for our state indexes to grow indefinitely. Furthermore, the requirement of state preservation for Flink State Index across version deployments and configuration updates adds complexity to the overall solution.&lt;/p&gt;

&lt;p&gt;Thus, we opted for the simple Bucket Index for its simplicity and the fact that our Hudi table size per partition does not change drastically across the week. However, this comes with a limitation whereby the number of buckets cannot be updated easily and imposes a parallelism limit at which our Flink pipelines can scale. Thus, as traffic grows organically, we would find ourselves in a situation whereby our configuration grows obsolete and cannot handle the increased load.&lt;/p&gt;

&lt;p&gt;To resolve this going forward, using consistent hashing for the Bucket Index would be something to explore to optimise our Parquet file sizes and allow the number of buckets to grow seamlessly as traffic grows.&lt;/p&gt;

&lt;h2 id=&quot;impact&quot;&gt;Impact&lt;/h2&gt;

&lt;h3 id=&quot;fresh-business-metrics&quot;&gt;Fresh business metrics&lt;/h3&gt;

&lt;p&gt;Post creation of our Hudi Data Ingestion solution, we have enabled various users such as our data analysts to perform ad hoc queries much more easily on data that has lower latency. Furthermore, Hudi tables can be seamlessly joined with Hive tables in Trino for additional context. This enabled the construction of operational dashboards reflecting fresh business metrics to our various operators, empowering them with the necessary information to quickly respond to any abnormalities (such as high-demand events like F1 or seasonal holidays).&lt;/p&gt;

&lt;h3 id=&quot;quicker-fraud-detection&quot;&gt;Quicker fraud detection&lt;/h3&gt;

&lt;p&gt;Another significant user of our solution is our fraud detection analysts. This enabled them to rapidly access fresh transaction events and analyse them for fraudulent patterns, particularly during the emergence of a new attack pattern that hadn’t been detected by their rules engine. Our solution also allowed them to perform multiple ad hoc queries that involve lookbacks of various days’ worth of data without impacting our production RDS and Kafka clusters by using the data lake as the data interface, reducing the data latency to the minute level and, in turn, empowering them to respond more quickly to attacks.&lt;/p&gt;

&lt;h2 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h2&gt;

&lt;p&gt;As the landscape of data storage solutions evolves rapidly, we are eager to test and integrate new features like Record Level Indexing and the creation of Pre Join tables. This evolution extends beyond the Hudi community to other table formats such as IceBerg and DeltaLake. We remain ready to adapt ourselves to these changes and incorporate the advantages of each format into our data lake within Grab.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Hudi: &lt;a href=&quot;https://hudi.apache.org/docs/next/overview/&quot;&gt;https://hudi.apache.org/docs/next/overview/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Ververica Flink CDC: &lt;a href=&quot;https://github.com/ververica/flink-cdc-connectors&quot;&gt;https://github.com/ververica/flink-cdc-connectors&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Debezium: &lt;a href=&quot;https://debezium.io/documentation/reference/stable/connectors/mysql.html&quot;&gt;https://debezium.io/documentation/reference/stable/connectors/mysql.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Fri, 23 Feb 2024 00:22:10 +0000</pubDate>
        <link>https://engineering.grab.com/enabling-near-realtime-data-analytics</link>
        <guid isPermaLink="true">https://engineering.grab.com/enabling-near-realtime-data-analytics</guid>
        
        <category>Data Analytics</category>
        
        <category>Stream Processing</category>
        
        <category>Kafka</category>
        
        <category>Real-Time</category>
        
        
        <category>Engineering</category>
        
        <category>Data Science</category>
        
      </item>
    
      <item>
        <title>The journey of building a comprehensive attribution platform</title>
        <description>&lt;p&gt;The Grab superapp offers a comprehensive array of services from ride-hailing and food delivery to financial services. This creates multifaceted user journeys, traversing homepages, product pages, checkouts, and interactions with diverse content, including advertisements and promo codes.&lt;/p&gt;

&lt;h2 id=&quot;background-why-ads-and-attribution-matter-in-our-superapp&quot;&gt;Background: Why ads and attribution matter in our superapp&lt;/h2&gt;

&lt;p&gt;Ads are crucial for Grab in driving user engagement and supporting our ecosystem by seamlessly connecting users with our services. In the ever-evolving world of advertising, the ability to gauge the impact of marketing investments takes on pivotal significance. Advertisers dedicate substantial resources to promote their businesses, necessitating a clear understanding of the return on AdSpend (ROAS) for each campaign. In this context, attribution plays a central role, serving as the guiding compass for advertisers and marketers, elucidating the effectiveness of touchpoints within campaigns.&lt;/p&gt;

&lt;p&gt;For instance, a merchant-partner seeks to enhance its reach by advertising on the Grab food delivery homepage. With the assistance of our attribution system, the merchant-partner can now precisely gauge the impact of their homepage ads on Grab. This involves tracking user engagement and monitoring the resulting orders that stem from these interactions. This level of granularity not only highlights the value of attribution but also demonstrates its capability in providing detailed insights into the effectiveness of advertising campaigns and enabling merchant-partners to optimise their campaigns with more precision.&lt;/p&gt;

&lt;p&gt;In this blog, we delve into the technical intricacies, software architecture, challenges, and solutions involved in crafting a state-of-the-art engineering solution for the attribution platform.&lt;/p&gt;

&lt;h2 id=&quot;genesis-pre-project-landscape&quot;&gt;Genesis: Pre-project landscape&lt;/h2&gt;

&lt;p&gt;When our journey began in 2020, Grab’s marketing efforts had limited attribution capabilities and data analytics was predominantly reliant on ad hoc queries conducted by business and data analysts. Before the introduction of a standardised approach, we had to manage discrepant results and a time-consuming manual process of data preparation, cleansing, and storage across teams. When issues arose in the analytical pipeline, resolution efforts took relatively longer and were reoccurring. We needed a comprehensive engineering solution that would address the identified gaps, and significantly enhance metrics related to ROI, attribution accuracy, and data-handling efficiency.&lt;/p&gt;

&lt;h2 id=&quot;inception-the-pure-ads-attribution-engine-kappa-architecture&quot;&gt;Inception: The pure ads attribution engine (Kappa architecture)&lt;/h2&gt;

&lt;p&gt;We chose Kappa architecture due to its imperative role in achieving near real-time attribution, especially in support of our new pricing model, cost per order (CPO). With this solution, we aimed to drastically reduce data latency from 2-3 days to just a few minutes. Traditional ETL (Extract, Transform, and Load) based batch processing methods were evaluated but quickly found to be inadequate for our purposes, mainly due to their speed.&lt;/p&gt;

&lt;p&gt;In the advertising industry, rapid decision-making is critical. Traditional batch processing solutions would introduce significant latency, hampering our ability to make real-time, data-driven decisions. With its architecture’s inherent capability for real-time stream processing, Kappa emerged as the logical choice. Additionally, Kappa offers the agility required to empower our ad-serving team for real-time decision support, and better ad ranking and selection, enabling dynamic and effective targeting decisions without delay.&lt;/p&gt;

&lt;p&gt;The first step on this journey was to create a pure and near real-time stream processing Ads Attribution Engine. This engine was based on the Kappa architecture to provide advertisers with quick insights into their ROAS offering real-time attribution, enabling advertisers to optimise their campaigns efficiently.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/attribution-platform/image6.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;High-level workflow of the Ads Attribution Engine&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;In this solution, we used the following tools in our tech stack:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kafka for event streams&lt;/li&gt;
  &lt;li&gt;DDB for events storage&lt;/li&gt;
  &lt;li&gt;Amazon S3 as the data lake&lt;/li&gt;
  &lt;li&gt;An in-house stream processing framework similar to Keystone&lt;/li&gt;
  &lt;li&gt;Redis for caching events&lt;/li&gt;
  &lt;li&gt;ScyllaDB for storing ad metadata&lt;/li&gt;
  &lt;li&gt;Amazon relational database service (RDS) for analytics&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/attribution-platform/image3.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Architecture of the near real-time stream processing Ads Attribution Engine&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;h2 id=&quot;evolution-merging-marketing-levers---ads-and-promos&quot;&gt;Evolution: Merging marketing levers - Ads and promos&lt;/h2&gt;

&lt;p&gt;We began to envision a world where we could merge various marketing levers into a unified Attribution Engine, starting with ads and promos. This evolved vision also aimed to prevent order double counting (when a user interacts with both ads and promos in the same checkout), which would provide a more holistic attribution solution.&lt;/p&gt;

&lt;p&gt;With the unified Attribution Engine, we would also enable more sophisticated personalisation through machine learning models and drive higher conversions.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/attribution-platform/image1.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;The unified Attribution Engine workflow, which included Promo touch points&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;The unified attribution engine used mostly the same tech stack, except for analytics where Druid was used instead of RDS.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/attribution-platform/image5.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Architecture of the unified Attribution Engine&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;h2 id=&quot;introspection-identifying-shortcomings-and-the-path-to-improvement&quot;&gt;Introspection: Identifying shortcomings and the path to improvement&lt;/h2&gt;

&lt;p&gt;While the unified attribution engine was a step in the right direction, it wasn’t without its challenges. There were challenges related to real-time data processing costs, scalability for longer attribution windows, latency and lag issues, out-of-order events leading to misattribution, and the complexity of implementing multi-touch attribution models. To truly empower advertisers and enhance the attribution process, we knew we needed to evolve further.&lt;/p&gt;

&lt;h2 id=&quot;rebirth-the-birth-of-a-full-fledged-attribution-platform-lambda-architecture&quot;&gt;Rebirth: The birth of a full-fledged attribution platform (&lt;a href=&quot;https://www.databricks.com/glossary/lambda-architecture&quot;&gt;Lambda architecture&lt;/a&gt;)&lt;/h2&gt;

&lt;p&gt;This journey eventually led us to build a full-fledged attribution platform using Lambda architecture, which blended both batch and real-time stream processing methods. With this change, our platform could rapidly and accurately process data and attribute the impact of ads and promos on user behaviour.&lt;/p&gt;

&lt;h3 id=&quot;why-lambdaarchitecture&quot;&gt;Why Lambda architecture?&lt;/h3&gt;

&lt;p&gt;This choice was a strategic one – real-time processing is vital for tracking events as they occur, but it offers only a current snapshot of user behaviour. This means we would not be able to analyse historical data, which is a crucial aspect of accurate attribution and exploring multiple attribution models. Historical data allows us to identify trends, patterns, and correlations not evident in real-time data alone.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/attribution-platform/image2.png&quot; alt=&quot;&quot; style=&quot;width:60%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;High level workflow for the full-fledged attribution platform with Lambda architecture&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;In this system’s tech stack, the key components are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Coban, an in-house stream processing framework used for real-time data processing&lt;/li&gt;
  &lt;li&gt;Spark-based ETL jobs for batch processing&lt;/li&gt;
  &lt;li&gt;Amazon S3 as the data warehouse&lt;/li&gt;
  &lt;li&gt;An offline layer that is capable of providing historical context, handling large data volumes, performing complex analytics, and so on.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;key-benefits-of-the-offline-layer&quot;&gt;Key benefits of the offline layer&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Provides historical context: The offline layer enriches the attribution process by providing a historical perspective on user interactions, essential for precise attribution analysis spanning extended time periods.&lt;/li&gt;
  &lt;li&gt;Handles enormous data volumes: This layer efficiently manages and processes extensive data generated by advertising campaigns, ensuring that attribution seamlessly accommodates large-scale data sets.&lt;/li&gt;
  &lt;li&gt;Performs complex analytics: Enables more intricate computations and data analysis than real-time processing alone, the offline layer is instrumental in fine-tuning attribution models and enhancing their accuracy.&lt;/li&gt;
  &lt;li&gt;Ensures reliability in the face of challenges: By providing fault tolerance and resilience against system failures, the offline layer ensures the continuous and dependable operation of the attribution system, even during unexpected events.&lt;/li&gt;
  &lt;li&gt;Optimises data storage and serving: Relying on Amazon S3, the storage layer for raw data optimises storage by building interactive reporting APIs.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/attribution-platform/image4.png&quot; alt=&quot;&quot; style=&quot;width:70%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Architecture of our comprehensive offline attribution platform&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;h3 id=&quot;challenges-with-lambda-and-mitigation&quot;&gt;Challenges with Lambda and mitigation&lt;/h3&gt;

&lt;p&gt;Lambda architecture allows us to have the accuracy and robustness of batch processing along with real-time stream processing. However, we noticed some drawbacks that may lead to complexity due to maintaining both batch and stream processing:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Operating two parallel systems for batch and stream processing can lead to increased complexity in production environments.&lt;/li&gt;
  &lt;li&gt;Lambda architecture requires two sets of business logic - one for the batch layer and another for the stream layer.&lt;/li&gt;
  &lt;li&gt;Synchronisation across both layers can make system alterations more challenging.&lt;/li&gt;
  &lt;li&gt;This dual implementation could also allude to inconsistencies and introduce potential bugs into the system.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To mitigate these complications, we’re establishing an optimisation strategy for our current system. By distinctly separating the responsibilities of our real-time pipelines from those of our offline jobs, we intend to harness the full potential of each approach, while simultaneously curbing the added complexity.&lt;/p&gt;

&lt;p&gt;Hence, redefining the way we utilise Lambda architecture, striking an efficient balance between real-time responsiveness and sturdy accuracy with the below proposal.&lt;/p&gt;

&lt;h2 id=&quot;vanguard-enhancements-in-the-future&quot;&gt;Vanguard: Enhancements in the future&lt;/h2&gt;

&lt;p&gt;In the coming months, we will be implementing the optimisation strategy and improving our attribution platform solution. This strategy can be broken down into the following sections.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Real-time pipeline handling time-sensitive data&lt;/strong&gt;: Real-time pipelines can process and deliver time-sensitive metrics like CPO-related data in near real-time, allowing for budget capping and immediate adjustments to marketing spend. This can provide us with actionable insights that can help with areas like real-time bidding, real-time marketing, or dynamic pricing. By limiting the volume of data through the real-time path, we can ensure it’s more manageable and focused on immediate actionable data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Batch jobs handling all other reporting data&lt;/strong&gt;: Batch processing is best suited for computations that are not time-bound and where completeness is more important. By dedicating more time to the processing phase, batch processing can handle larger volumes and more complex computations, providing more comprehensive and accurate reporting.&lt;/p&gt;

&lt;p&gt;This approach will simplify our Lambda architecture, as the batch and real-time pipelines will have clear separation of duties. It may also reduce the chance of discrepancies between the real-time and batch-processing datasets and lower the operational load of our real-time system.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-a-holistic-attribution-picture&quot;&gt;Conclusion: A holistic attribution picture&lt;/h2&gt;

&lt;p&gt;Through our journey of building a comprehensive attribution platform, we can now deliver a holistic and dependable view of user behaviour and empower merchant-partners to use insights from advertisements and promotions. This journey has been a long one, but we were able to improve our attribution solution in several ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Attribution latency: Successfully reduced attribution latency from 2-3 days to just a few minutes, ensuring that advertisers can access real-time insights and feedback.&lt;/li&gt;
  &lt;li&gt;Data accuracy: Through improved data collection and processing, we achieved data discrepancies of less than 1%, enhancing the accuracy and reliability of attribution data.&lt;/li&gt;
  &lt;li&gt;Conversion rate: Advertisers witnessed a significant increase in conversion rates, a direct result of our real-time attribution capabilities.&lt;/li&gt;
  &lt;li&gt;Cost efficiency: Embracing the Lambda architecture led to a ~25% reduction in real-time data processing costs, allowing for more efficient campaign optimisations.&lt;/li&gt;
  &lt;li&gt;Operational resilience: Building an offline layer provided fault tolerance and resilience against system failures, ensuring that our attribution system continued to operate seamlessly, even during unexpected events.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Feb 2024 00:22:10 +0000</pubDate>
        <link>https://engineering.grab.com/attribution-platform</link>
        <guid isPermaLink="true">https://engineering.grab.com/attribution-platform</guid>
        
        <category>Attribution platform</category>
        
        <category>User journeys</category>
        
        <category>Advertising</category>
        
        
        <category>Engineering</category>
        
        <category>Product</category>
        
        <category>Design</category>
        
      </item>
    
      <item>
        <title>Managing dynamic marketplace content at scale: Grab&apos;s approach to content moderation</title>
        <description>&lt;p&gt;In the fast-paced world of on-demand delivery, maintaining safe marketplaces is a complex undertaking. Grab, a leading superapp in Southeast Asia, operates GrabFood and GrabMart, two popular marketplaces that connect consumers with a wide range of food and daily necessities. With more than 100k listings for different items updated daily by our merchants across eight different countries, Grab is rising to the challenge of ensuring that its marketplaces remain compliant with its own policies, government regulations as well as platform policies.&lt;/p&gt;

&lt;p&gt;This article explores how Grab employs a combination of automated and manual content moderation to manage its dynamic marketplace content efficiently, while also collaborating with Google to ensure marketplace safety.&lt;/p&gt;

&lt;h2 id=&quot;dynamic-marketplace-landscape&quot;&gt;Dynamic Marketplace Landscape&lt;/h2&gt;

&lt;p&gt;Marketplaces like GrabFood and GrabMart are at the forefront of connecting merchants and consumers. These marketplaces provide an avenue for merchants to showcase their offerings, enabling consumers to conveniently access a plethora of on-demand options. However, in an environment characterized by rapid changes as well as evolving regulatory frameworks, maintaining the integrity of these marketplaces becomes a formidable task.&lt;/p&gt;

&lt;h2 id=&quot;scale-and-flexibility-a-dual-challenge&quot;&gt;Scale and Flexibility: A Dual Challenge&lt;/h2&gt;

&lt;p&gt;The cornerstone of Grab’s success lies in its ability to adapt to the unique regulations and requirements of each country it operates in. This necessitates a nuanced and multifaceted approach to content moderation. To achieve both scale and flexibility, Grab employs a proactive strategy that combines and leverages automated and manual moderation processes.&lt;/p&gt;

&lt;h2 id=&quot;automated-moderation&quot;&gt;Automated Moderation&lt;/h2&gt;

&lt;p&gt;Automated moderation plays a pivotal role in efficiently managing the high volume of listings that undergo daily updates. Grab utilises advanced algorithms and machine learning technologies, built in-house, to scan listings everyday for potential violations of its own policies, government regulations and platform policies. This automation not only speeds up the process to put eligible listings on the Grab platform, but also ensures consistent adherence to predefined guidelines. However, automated moderation is not without its limitations, as contextual understanding and subjective judgment often require human intervention.&lt;/p&gt;

&lt;h2 id=&quot;manual-moderation&quot;&gt;Manual Moderation&lt;/h2&gt;

&lt;p&gt;Recognising the nuanced nature of content moderation, Grab employs a team of human moderators who possess the cultural awareness and contextual understanding necessary to assess complex cases. These moderators review listings flagged by algorithms and machine learning technologies that require human judgment, ensuring that content aligns with Grab’s policies, local regulations as well as platform policies. Manual moderation adds a layer of human insight that automated systems may lack, contributing to a more accurate and contextually sensitive approach.&lt;/p&gt;

&lt;p&gt;In its commitment to ensuring marketplace safety, Grab has also established a strong collaboration with Google. Grab works hand in hand with Google to collectively ensure adherence to Play Store policies and guidelines.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;grab&quot;&gt;Grab&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Programme Management: Poonam Gambhire, Shuyang Sun&lt;/li&gt;
  &lt;li&gt;Product: Chris Collard&lt;/li&gt;
  &lt;li&gt;Engineering: Shuya Ding, Kirubakaran Duraisamy, Xu Chen&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;google&quot;&gt;Google&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Play Policy: Siddhartha Paul Tiwari&lt;/li&gt;
  &lt;li&gt;Business Development: Mika Igarashi&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Feb 2024 00:22:10 +0000</pubDate>
        <link>https://engineering.grab.com/dynamic-marketplace</link>
        <guid isPermaLink="true">https://engineering.grab.com/dynamic-marketplace</guid>
        
        <category>Dynamic marketplace</category>
        
        <category>Content moderation</category>
        
        <category>Scaling</category>
        
        
        <category>Product</category>
        
      </item>
    
      <item>
        <title>Rethinking Stream Processing: Data Exploration</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In this digital age, companies collect multitudes of data that enable the tracking of business metrics and performance. Over the years, data analytics tools for data storage and processing have evolved from the days of Excel sheets and macros to more advanced Map Reduce model tools like Spark, Hadoop, and Hive. This evolution has allowed companies, including Grab, to perform modern analytics on the data ingested into the Data Lake, empowering them to make better &lt;strong&gt;data-driven business decisions&lt;/strong&gt;. This form of data will be referenced within this document as &lt;strong&gt;“Offline Data”&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;With innovations in stream processing technology like Spark and Flink, there is now more interest in unlocking value from streaming data. This form of continuously-generated data in high volume will be referenced within this document as &lt;strong&gt;“Online Data”&lt;/strong&gt;. In the context of Grab, the streaming data is usually materialised as Kafka topics (“Kafka Stream”) as the result of stream processing in its framework. This data is largely unexplored until they are eventually sunk into the Data Lake as Offline Data, part of the data journey (see Figure 1 below). This induces some data latency before the data can be used by data analysts to inform decisions.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/rethinking-streaming-processing-data-exploration/figure-1-data-journey-online-offline-data.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Figure 1. Simplified data journey for Offline Data vs. Online Data, from data generation to data analysis.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;As seen in Figure 1 above, the &lt;strong&gt;Time to Value (“TTV”)&lt;/strong&gt; of Online Data is shorter as compared to that of Offline Data in a simplified data journey from data generation to data analysis where complexities of data cleaning and transformation have been removed. This is because the role of the data analyst or data scientist (“Data End User”) has been enabled forward to the Kafka stage for Online Data instead of the Data Lake stage for Offline Data. We recognise that allowing earlier data exploration on Online Data allows Data End Users to build context around the data inputs they are using in an earlier stage. This can help them process Offline Data more meaningfully in subsequent stages. We are interested in opening up the possibility for Data End Users to at least explore the Online Data before they architect a full solution to clean and/or process the data directly or more efficiently post-ingestion into the Data Lake. After their data exploration, the users would have more information to decide whether to spin up a stream processing pipeline for Online Data, or to continue processing Offline Data with their current solution, but with a more refined understanding and logic strategy against their source data inputs. However, of course, in this blog, we acknowledge that not all analysis on Online Data could be done in this manner.&lt;/p&gt;

&lt;h2 id=&quot;problem-statement&quot;&gt;Problem statement&lt;/h2&gt;

&lt;p&gt;Online Data is underutilised within Grab mainly because of, among other reasons, difficulty in performing data exploration on data that is not yet properly stored in the Data Lake.&lt;/p&gt;

&lt;p&gt;For the purpose of this blog post, we will focus only on the problem of exploration of Online Data because this problem is the precursor to allowing us to fully democratise such data.&lt;/p&gt;

&lt;p&gt;The problem of data exploration manifests itself when Data End Users need to find the proper data inputs to base and develop their data models. These users would then often need to parse through a multitude of documentation and connect with multiple upstream data producers, to know the range of data signals that are currently available and understand what each data signal is trying to measure.&lt;/p&gt;

&lt;p&gt;Given the ephemeral nature of Online Data, this implies that the &lt;strong&gt;lack of correct tool adoption&lt;/strong&gt; to seamlessly perform quick tests with application logic on Online Data disincentivises the Data End Users to work on these Online Data. Testing such logic on Offline Data is generally much easier since iteration testing on the exact same dataset is possible.&lt;/p&gt;

&lt;p&gt;This difficulty in &lt;strong&gt;performing data exploration including ad hoc queries on Online Data&lt;/strong&gt; has therefore made development of stream processing applications hard for Data End Users, creating headwinds in Grab’s aim to evolve from making &lt;strong&gt;data-driven business decisions&lt;/strong&gt; to also making &lt;strong&gt;data-driven operation decisions&lt;/strong&gt;. Doing both would allow Grab to react much quicker to abrupt changes in its business landscape.&lt;/p&gt;

&lt;h2 id=&quot;adoption-of-zeppelin-notebook-environment&quot;&gt;Adoption of Zeppelin notebook environment&lt;/h2&gt;

&lt;p&gt;To address the difficulty in performing data exploration on Online Data, we have adopted &lt;a href=&quot;https://zeppelin.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Zeppelin&lt;/a&gt;, a web-based notebook that enables data-drive, interactive data analytics with the support of multiple interpreters to work with various data processing backends e.g. Spark, Flink. The full solution of the adopted Zeppelin notebook environment is enabled seamlessly within our internal data-streaming platform, through its control plane. If you are interested, you may check out our previous blog post titled &lt;a href=&quot;/an-elegant-platform&quot; target=&quot;_blank&quot;&gt;An elegant platform&lt;/a&gt; for more details on the abovementioned streaming platform and its control plane.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/rethinking-streaming-processing-data-exploration/figure-2-zeppelin-enablement.png&quot; alt=&quot;&quot; style=&quot;width:60%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Figure 2. Zeppelin login page via web-based notebook environment.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;As seen from Figure 2 above, after successful creation of the Zeppelin cluster, users can log in with their generated credentials delivered to them via the integrated instant messenger, and start using the notebook environment.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/rethinking-streaming-processing-data-exploration/figure-3-process-data-exploration-online-data.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Figure 3. Zeppelin programme flow in the notebook environment.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Figure 3 above explains the Zeppelin notebook programme flow as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The users enter their queries into the notebook session and run querying statements interactively with the established web-based notebook session.&lt;/li&gt;
  &lt;li&gt;The queries are passed to the Flink interpreter within the cluster to generate the Flink job as a Jar file, to be then submitted to a Flink session cluster.&lt;/li&gt;
  &lt;li&gt;When the Flink session cluster job manager receives the job, it would spin up the corresponding Flink task managers (workers) to run the application and retrieve the results.&lt;/li&gt;
  &lt;li&gt;The query results would then be piped back to the notebook session, to be displayed back to the user on the notebook session.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;data-query-and-visualisation&quot;&gt;Data query and visualisation&lt;/h2&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/rethinking-streaming-processing-data-exploration/figure-4-example-query-on-kafka-data.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Figure 4. Example of simple select query of data on Kafka. &lt;br /&gt;Note: All variable names, schema, values, and other details used in this article are only created for use as examples.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Flink has a planned roadmap to create a unified streaming language for both stream processing and data analytics. In line with the roadmap, we have based our Zeppelin solution on supporting Structured Query Language (“SQL”) as the query language of choice as seen in Figure 4 above. Data End Users can now write queries in SQL, which is a language that they are comfortable with, and perform adequate data exploration.&lt;/p&gt;

&lt;p&gt;As discussed in this section, data exploration on streaming data at the Kafka stage by adopting the right tool enables Data End Users to seamlessly have visibility to quickly understand the current schema of a Kafka topic (explained more in the next &lt;a href=&quot;#need-for-dynamic-table-schema&quot;&gt;section&lt;/a&gt;. This kind of data exploration also enables Data End Users to understand the type of data the Kafka topic represents, such as the ability to determine if a country code data field is in alpha-2 or alpha-3 &lt;a href=&quot;https://www.iso.org/iso-3166-country-codes.html#:~:text=The%20country%20codes%20can%20be,to%20avoid%20using%20Latin%20script&quot; target=&quot;_blank&quot;&gt;format&lt;/a&gt; while the data is still part of streaming data. This might seem inconsequential and immediately identifiable even in Offline Data, but by enabling data exploration at an earlier stage in the data journey for Online Data, Data End Users have the opportunity to react much more quickly. For example, a change of expected country code format from the data producer would usually lead to errors in the downstream joins or other stream processing pipelines due to incompatible parsing or filtering of the modified country codes. Instead of waiting for the data to be ingested to Offline Data, users can investigate the issue with Online Data retrieved from Kafka.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/rethinking-streaming-processing-data-exploration/figure-5-data-visualisation-on-kafka-data.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Figure 5. Simple visualisation of queried data on Zeppelin’s notebook environment. &lt;br /&gt;Note: All variable names, schema, values, and other details used in this article are only created for use as examples.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Besides query features, Zeppelin notebook provides simple visualisation and analytics of the off-the-shelf data as presented above in Figure 5. Furthermore, users are now able to perform interactive ad hoc queries on Online Data. These queries will eventually become much more advanced and/or effective SQL queries to be deployed as a streaming pipeline later on in the data journey. This reduces the inertia in setting up a separate development environment or learning other programming languages like Java or Scala during the development of streaming pipelines. With Zeppelin’s notebook environment, our Data End Users are more empowered to quickly derive value from Online Data.&lt;/p&gt;

&lt;h2 id=&quot;need-for-a-more-dynamic-table-schema-derivation-process-&quot;&gt;Need for a more dynamic table schema derivation process &lt;a id=&quot;need-for-dynamic-table-schema&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;For the Data End Users performing data exploration on Online Data, we see a need for these users to derive the Data Definition Language (“DDL”) associated with a Kafka stream at an earlier stage of the data journey. Within Grab, even though Kafka streams are transmitted in &lt;a href=&quot;https://protobuf.dev/&quot; target=&quot;_blank&quot;&gt;Protobuf&lt;/a&gt; format and are thus structured, both the schema and the corresponding DDL changes are added over time as new fields. Typically, the data producer (service owners) and the data engineers responsible for the data ingestion pipeline coordinate to perform such updates. Since the  Data End Users are not involved in such schema update processes nor do they directly interact with the data producers, many of them find the discovery of changes in the current Kafka stream schema an issue. Granted that this is an issue our metadata platform is actively solving using &lt;a href=&quot;https://datahubproject.io/&quot; target=&quot;_blank&quot;&gt;Datahub&lt;/a&gt;, we hope to also solve the challenge by being able to derive the DDL more dynamically within the tooling, for data exploration on Online Data to reduce friction.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/rethinking-streaming-processing-data-exploration/figure-6-derive-schema-kafka-data.png&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Figure 6. Common functions to derive DDL of a Kafka Stream in SQL. &lt;br /&gt;Note: All variable names, schema, values, and other details used in this article are only created for use as examples.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;As seen from Figure 6 above, we have an integrated tooling for Data End Users to derive the DDL associated with a Kafka stream using SQL language. A Kafka stream in Grab’s context is a logical concept describing a Kafka topic, associating it with its metadata like Kafka bootstrap servers and associated Java class created by &lt;a href=&quot;https://grpc.io/docs/protoc-installation/&quot; target=&quot;_blank&quot;&gt;Protoc&lt;/a&gt;. This tool maps the Protobuf schema definition of a Kafka stream to a DDL, allowing it to be expressed and used in SQL language. This reduces the manual effort involved in creating these table definitions from scratch based on the associated Protobuf schema. Users can now derive the DDL associated with a Kafka stream more easily.&lt;/p&gt;

&lt;h2 id=&quot;mitigating-risks-arising-from-data-exploration-on-online-data---data-access-authorisationaudit&quot;&gt;Mitigating risks arising from data exploration on Online Data - data access authorisation/audit&lt;/h2&gt;
&lt;p&gt;While we rethink stream processing and are open to options that enable data exploration on Online Data as mentioned above, we realised that new security requirements related to data access authorisation and maintaining proper audit trail have emerged. Even with Personally Identifiable Information (PII) obfuscation enforcement by our streaming pipeline, it means we need to implement stricter guardrails in place along with audit trails to ensure users only have access to what they are allowed to, and this access can be removed in a break-glass scenario. If you are interested, you may check out our previous blog post titled &lt;a href=&quot;/pii-masking&quot; target=&quot;_blank&quot;&gt;PII masking for privacy-grade machine learning&lt;/a&gt; for more details about how we enforce PII masking on machine learning data streaming pipelines.&lt;/p&gt;

&lt;p&gt;To enable data access authorisation, we utilised Strimzi, the operator of running Kafka on Kubernetes. We integrated Strimzi’s Open Policy Agent (&lt;a href=&quot;https://www.openpolicyagent.org/&quot; target=&quot;_blank&quot;&gt;OPA&lt;/a&gt;) with Kafka to define policies that authorise specific read-only user access to specific Kafka Topics. The identification of users is done via mutualTLS (&lt;a href=&quot;https://docs.confluent.io/platform/current/kafka/configure-mds/mutual-tls-auth-rbac.html#principal-mapping-rules-for-ssl-listeners-extract-a-principal-from-a-certificate&quot; target=&quot;_blank&quot;&gt;mTLS&lt;/a&gt;) connection with our Kafka clusters, where their user details are part of the SSL certificate details used for authentication.&lt;/p&gt;

&lt;p&gt;With these tools in place, each user’s request to explore Online Data would be properly logged, and each data access can be controlled by an OPA policy managed by a central team.&lt;/p&gt;

&lt;p&gt;If you are interested, you may check out our previous post &lt;a href=&quot;/zero-trust-with-kafka&quot; target=&quot;_blank&quot;&gt;Zero trust with Kafka&lt;/a&gt; where we discussed our efforts to continue strengthening the security of our data-streaming platform.&lt;/p&gt;

&lt;h2 id=&quot;impact&quot;&gt;Impact&lt;/h2&gt;

&lt;p&gt;With the proliferation of our data-streaming platform, we expect to see improvements in the way our data becomes gradually democratised. We have already been receiving use cases from the Data End Users who are interested in validating a chain of events on Online Data, i.e. retrieving information of all events associated with a particular booking, which is not currently something that can be done easily.&lt;/p&gt;

&lt;p&gt;More importantly, the tools in place for data exploration on Online Data form the foundation required for us to embark on our next step of the stream processing journey. This foundation makes the development and validation of the stream processing logic much quicker. This occurs when ad hoc queries in a notebook environment are possible, removing the need for local developer environment setups and the need to go through the whole pipeline deployment process for eventual validation of the developed logic. We believe that this would prove to reduce our lead time in creating stream processing pipelines significantly.&lt;/p&gt;

&lt;h2 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h2&gt;

&lt;p&gt;Our next step is to rethink further how our stream processing pipelines are defined and start to provision SQL as the unified streaming language of our pipelines. This helps facilitate better discussion between upstream data producers, data engineers, and Data End Users, since SQL is the common language among these stakeholders.&lt;/p&gt;

&lt;p&gt;We will also explore handling schema discovery in a more controlled manner by utilising a Hive catalogue to store our Kafka table definitions. This removes the need for users to retrieve and run the table DDL statement for every session, making the data exploration experience even more seamless.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zeppelin.apache.org/&quot;&gt;[1] Apache Zeppelin | Web-based notebook that enables data-driven, interactive data analytics and collaborative documents with SQL, Scala, Python, R and more.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://engineering.grab.com/an-elegant-platform&quot;&gt;[2] An elegant platform | Grab engineering blog.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://flink.apache.org/what-is-flink/roadmap/#unified-sql-platform&quot;&gt;[3] Apache Flink | Roadmap on Unified SQL Platform.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.iso.org/iso-3166-country-codes.html#:~:text=The%20country%20codes%20can%20be,to%20avoid%20using%20Latin%20script&quot;&gt;[4] ISO | ISO 3166 Country Codes.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://protobuf.dev/&quot;&gt;[5] Protobuf (Protocol Buffers)| Language-neutral, platform-neutral extensible mechanisms for serializing structured data.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://datahubproject.io/&quot;&gt;[6] Datahub | Extensible metadata platform that enables data discovery, data observability and federated governance to help tame the complexity of your data ecosystem.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://grpc.io/docs/protoc-installation/&quot;&gt;[7] Protoc | Protocol buffer compiler installation.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://engineering.grab.com/pii-masking&quot;&gt;[8] PII masking for privacy-grade machine learning | Grab engineering blog.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://engineering.grab.com/zero-trust-with-kafka&quot;&gt;[9] Zero trust with Kafka | Grab engineering blog.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.openpolicyagent.org/&quot;&gt;[10] Open Policy Agent (OPA) | Policy-based control for cloud native environments.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://strimzi.io/blog/2020/08/05/using-open-policy-agent-with-strimzi-and-apache-kafka/&quot;&gt;[11] Strimzi | Using Open Policy Agent with Strimzi and Apache Kafka.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.confluent.io/platform/current/kafka/configure-mds/mutual-tls-auth-rbac.html#principal-mapping-rules-for-ssl-listeners-extract-a-principal-from-a-certificate&quot;&gt;[12] Confluent Documentation | Configure mTLS authentication and RBAC for kafka brokers.&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Jan 2024 00:10:10 +0000</pubDate>
        <link>https://engineering.grab.com/rethinking-streaming-processing-data-exploration</link>
        <guid isPermaLink="true">https://engineering.grab.com/rethinking-streaming-processing-data-exploration</guid>
        
        <category>Kafka</category>
        
        <category>Kubernetes</category>
        
        <category>Data Streaming</category>
        
        <category>Deployments</category>
        
        <category>Streaming applications</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>Kafka on Kubernetes: Reloaded for fault tolerance</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Coban - Grab’s real-time data streaming platform - has been operating &lt;a href=&quot;https://kafka.apache.org/&quot;&gt;Kafka&lt;/a&gt; on &lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt; with &lt;a href=&quot;https://strimzi.io/&quot;&gt;Strimzi&lt;/a&gt; in 
production for about two years. In a previous article (&lt;a href=&quot;/zero-trust-with-kafka&quot;&gt;Zero trust with Kafka&lt;/a&gt;), we explained how we leveraged Strimzi to enhance the security of our data streaming offering.&lt;/p&gt;

&lt;p&gt;In this article, we are going to describe how we improved the fault tolerance of our initial design, to the point where we no longer need to intervene if a Kafka broker is unexpectedly terminated.&lt;/p&gt;

&lt;h2 id=&quot;problem-statement&quot;&gt;Problem statement&lt;/h2&gt;

&lt;p&gt;We operate Kafka in the AWS Cloud. For the Kafka on Kubernetes design described in this article, we rely on &lt;a href=&quot;https://aws.amazon.com/eks/&quot;&gt;Amazon Elastic Kubernetes Service&lt;/a&gt; (EKS), the managed Kubernetes offering by AWS, with the worker nodes deployed as &lt;a href=&quot;https://docs.aws.amazon.com/eks/latest/userguide/worker.html&quot;&gt;self-managed nodes&lt;/a&gt; on &lt;a href=&quot;https://aws.amazon.com/ec2/&quot;&gt;Amazon Elastic Compute Cloud&lt;/a&gt; (EC2).&lt;/p&gt;

&lt;p&gt;To make our operations easier and limit the blast radius of any incidents, we deploy exactly one Kafka cluster for each EKS cluster. We also give a full worker node to each Kafka broker. In terms of storage, we initially relied on EC2 instances with &lt;a href=&quot;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html&quot;&gt;non-volatile memory express (NVMe) instance store volumes&lt;/a&gt; for 
maximal I/O performance. Also, each Kafka cluster is accessible beyond its own &lt;a href=&quot;https://aws.amazon.com/vpc/&quot;&gt;Virtual Private Cloud&lt;/a&gt; (VPC) via a &lt;a href=&quot;https://docs.aws.amazon.com/vpc/latest/privatelink/privatelink-share-your-services.html&quot;&gt;VPC Endpoint Service&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/kafka-on-kubernetes/image5.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig. 1 Initial design of a 3-node Kafka cluster running on Kubernetes.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Fig. 1 shows a logical view of our initial design of a 3-node Kafka on Kubernetes cluster, as typically run by Coban. The Zookeeper and Cruise-Control components are not shown for clarity.&lt;/p&gt;

&lt;p&gt;There are four Kubernetes services (1): one for the initial connection - referred to as “bootstrap” - that redirects incoming traffic to any Kafka pods, plus one for each Kafka pod, for the clients to target each Kafka broker individually (a requirement to produce or consume from/to a partition that resides on any particular Kafka broker). Four different listeners on the Network Load Balancer (NLB) listening on four different TCP ports, enable the Kafka clients to target either the bootstrap 
service or any particular Kafka broker they need to reach. This is very similar to what we previously described in &lt;a href=&quot;/exposing-kafka-cluster&quot;&gt;Exposing a Kafka Cluster via a VPC Endpoint Service&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Each worker node hosts a single Kafka pod (2). The NVMe instance store volume is used to create a Kubernetes Persistent Volume (PV), attached to a pod via a Kubernetes Persistent Volume Claim (PVC).&lt;/p&gt;

&lt;p&gt;Lastly, the worker nodes belong to &lt;a href=&quot;https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html&quot;&gt;Auto-Scaling Groups&lt;/a&gt; (ASG) (3), one by &lt;a href=&quot;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones&quot;&gt;Availability Zone&lt;/a&gt; (AZ). Strimzi adds in node affinity to make sure that the brokers are evenly distributed across AZs. In this initial design, ASGs are not for auto-scaling though, because we want to keep the size of the cluster under control. We only use ASGs - with a fixed size - to facilitate manual scaling operation and to automatically replace the terminated worker nodes.&lt;/p&gt;

&lt;p&gt;With this initial design, let us see what happens in case of such a worker node termination.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/kafka-on-kubernetes/image4.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig. 2 Representation of a worker node termination. Node C is terminated and replaced by node D. However the Kafka broker 3 pod is unable to restart on node D.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Fig. 2 shows the worker node C being terminated along with its NVMe instance store volume C, and replaced (by the ASG) by a new worker node D and its new, empty NVMe instance store volume D. On start-up, the worker node D automatically joins the Kubernetes cluster. The Kafka broker 3 pod that was running on the faulty worker node C is scheduled to restart on the new worker node D.&lt;/p&gt;

&lt;p&gt;Although the NVMe instance store volume C is terminated along with the worker node C, there is no data loss because all of our Kafka topics are configured with a minimum of three replicas. The data is poised to be copied over from the surviving Kafka brokers 1 and 2 back to Kafka broker 3, as soon as Kafka broker 3 is effectively restarted on the worker node D.&lt;/p&gt;

&lt;p&gt;However, there are three fundamental issues with this initial design:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The Kafka clients that were in the middle of producing or consuming to/from the partition leaders of Kafka broker 3 are suddenly facing connection errors, because the broker was not gracefully demoted beforehand.&lt;/li&gt;
  &lt;li&gt;The target groups of the NLB for both the bootstrap connection and Kafka broker 3 still point to the worker node C. Therefore, the network communication from the NLB to Kafka broker 3 is broken. A manual reconfiguration of the target groups is required.&lt;/li&gt;
  &lt;li&gt;The PVC associating the Kafka broker 3 pod with its instance store PV is unable to automatically switch to the new NVMe instance store volume of the worker node D. Indeed, static provisioning is an intrinsic characteristic of Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/volumes/#local&quot;&gt;local volumes&lt;/a&gt;. The PVC is still in &lt;em&gt;Bound&lt;/em&gt; state, so Kubernetes does not take any action. However, the actual storage beneath the PV does not exist anymore. Without any storage, the Kafka broker 3 pod is unable to start.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this stage, the Kafka cluster is running in a degraded state with only two out of three brokers, until a Coban engineer intervenes to reconfigure the target groups of the NLB and delete the zombie PVC (this, in turn, triggers its re-creation by Strimzi, this time using the new instance store PV).&lt;/p&gt;

&lt;p&gt;In the next section, we will see how we have managed to address the three issues mentioned above to make this design fault-tolerant.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&quot;graceful-kafka-shutdown&quot;&gt;Graceful Kafka shutdown&lt;/h3&gt;

&lt;p&gt;To minimise the disruption for the Kafka clients, we leveraged the &lt;a href=&quot;https://aws-quickstart.github.io/cdk-eks-blueprints/addons/aws-node-termination-handler/&quot;&gt;AWS Node Termination Handler&lt;/a&gt; (NTH). This component provided by AWS for Kubernetes environments is able to cordon and drain a worker node that is going to be terminated. This draining, in turn, triggers a graceful shutdown of the Kafka 
process by sending a polite &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html&quot;&gt;SIGTERM&lt;/a&gt; signal to all pods running on the worker node that is being drained (instead of the brutal &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html&quot;&gt;SIGKILL&lt;/a&gt; of a normal termination).&lt;/p&gt;

&lt;p&gt;The termination events of interest that are captured by the NTH are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scale-in operations by an ASG.&lt;/li&gt;
  &lt;li&gt;Manual termination of an instance.&lt;/li&gt;
  &lt;li&gt;AWS maintenance events, typically EC2 instances scheduled for upcoming retirement.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This suffices for most of the disruptions our clusters can face in normal times and our common maintenance operations, such as terminating a worker node to refresh it. Only sudden hardware failures (AWS issue events) would fall through the cracks and still trigger errors on the Kafka client side.&lt;/p&gt;

&lt;p&gt;The NTH comes in two modes: &lt;a href=&quot;https://github.com/aws/aws-node-termination-handler#major-features&quot;&gt;Instance Metadata Service (IMDS) and Queue Processor&lt;/a&gt;. We chose to go with the latter as it is able to capture a broader range of events, widening the fault tolerance capability.&lt;/p&gt;

&lt;h4 id=&quot;scale-in-operations-by-an-asg&quot;&gt;Scale-in operations by an ASG&lt;/h4&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/kafka-on-kubernetes/image2.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig. 3 Architecture of the NTH with the Queue Processor.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Fig. 3 shows the NTH with the Queue Processor in action, and how it reacts to a scale-in operation (typically triggered manually, during a maintenance operation):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;As soon as the scale-in operation is triggered, an &lt;a href=&quot;https://docs.aws.amazon.com/autoscaling/ec2/userguide/lifecycle-hooks.html&quot;&gt;Auto Scaling lifecycle hook&lt;/a&gt; is invoked to pause the termination of the instance.&lt;/li&gt;
  &lt;li&gt;Simultaneously, an Auto Scaling lifecycle hook event is issued to an &lt;a href=&quot;https://aws.amazon.com/sqs/&quot;&gt;Amazon Simple Queue Service&lt;/a&gt; (SQS) queue. In Fig. 3, we have also materialised EC2 events (e.g. manual termination of an instance, AWS maintenance events, etc.) that transit via &lt;a href=&quot;https://aws.amazon.com/eventbridge/&quot;&gt;Amazon EventBridge&lt;/a&gt; to eventually end up in the same SQS queue. We will discuss EC2 events in the next two sections.&lt;/li&gt;
  &lt;li&gt;The NTH, a pod running in the Kubernetes cluster itself, constantly polls that SQS queue.&lt;/li&gt;
  &lt;li&gt;When a scale-in event pertaining to a worker node of the Kubernetes cluster is read from the SQS queue, the NTH sends to the Kubernetes API the instruction to &lt;a href=&quot;https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration&quot;&gt;cordon&lt;/a&gt; and &lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/&quot;&gt;drain&lt;/a&gt; the impacted worker node.&lt;/li&gt;
  &lt;li&gt;On draining, Kubernetes sends a SIGTERM signal to the Kafka pod residing on the worker node.&lt;/li&gt;
  &lt;li&gt;Upon receiving the SIGTERM signal, the Kafka pod gracefully migrates the leadership of its leader partitions to other brokers of the cluster before shutting down, in a transparent manner for the clients. This behaviour is ensured by the &lt;a href=&quot;https://kafka.apache.org/documentation/#basic_ops_restarting&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;controlled.shutdown.enable&lt;/code&gt;&lt;/a&gt; parameter of Kafka, which is enabled by default.&lt;/li&gt;
  &lt;li&gt;Once the impacted worker node has been drained, the NTH eventually resumes the termination of the instance.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Strimzi also comes with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terminationGracePeriodSeconds&lt;/code&gt; parameter, which we have set to 180 seconds to give the Kafka pods enough time to migrate all of their partition leaders gracefully on termination. We have verified that this is enough to migrate all partition leaders on our Kafka clusters (about 60 seconds for 600 partition leaders).&lt;/p&gt;

&lt;h4 id=&quot;manual-termination-of-an-instance&quot;&gt;Manual termination of an instance&lt;/h4&gt;

&lt;p&gt;The Auto Scaling lifecycle hook that pauses the termination of an instance (Fig. 3, step 1) as well as the corresponding resuming by the NTH (Fig. 3, step 7) are invoked only for ASG scaling events.&lt;/p&gt;

&lt;p&gt;In case of a manual termination of an EC2 instance, the termination is captured as an EC2 event that also reaches the NTH. Upon receiving that event, the NTH cordons and drains the impacted worker node. However, the instance is immediately terminated, most likely before the leadership of all of its Kafka partition leaders has had the time to get migrated to other brokers.&lt;/p&gt;

&lt;p&gt;To work around this and let a manual termination of an EC2 instance also benefit from the ASG lifecycle hook, the instance must be terminated using the &lt;a href=&quot;https://docs.aws.amazon.com/cli/latest/reference/autoscaling/terminate-instance-in-auto-scaling-group.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terminate-instance-in-auto-scaling-group&lt;/code&gt;&lt;/a&gt; AWS CLI command.&lt;/p&gt;

&lt;h4 id=&quot;aws-maintenance-events&quot;&gt;AWS maintenance events&lt;/h4&gt;

&lt;p&gt;For AWS maintenance events such as instances scheduled for upcoming retirement, the NTH acts immediately when the event is first received (typically adequately in advance). It cordons and drains the soon-to-be-retired worker node, which in turn triggers the SIGTERM signal and the graceful termination of Kafka as described above. At this stage, the impacted instance is not terminated, so the Kafka partition leaders have plenty of time to complete their migration to other brokers.&lt;/p&gt;

&lt;p&gt;However, the evicted Kafka pod has nowhere to go. There is a need for spinning up a new worker node for it to be able to eventually restart somewhere.&lt;/p&gt;

&lt;p&gt;To make this happen seamlessly, we doubled the maximum size of each of our ASGs and installed the &lt;a href=&quot;https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md&quot;&gt;Kubernetes Cluster Autoscaler&lt;/a&gt;. With that, when such a maintenance event is received:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The worker node scheduled for retirement is cordoned and drained by the NTH. The state of the impacted Kafka pod becomes &lt;em&gt;Pending&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;The Kubernetes Cluster Autoscaler comes into play and triggers the corresponding ASG to spin up a new EC2 instance that joins the Kubernetes cluster as a new worker node.&lt;/li&gt;
  &lt;li&gt;The impacted Kafka pod restarts on the new worker node.&lt;/li&gt;
  &lt;li&gt;The Kubernetes Cluster Autoscaler detects that the previous worker node is now under-utilised and terminates it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this scenario, the impacted Kafka pod only remains in &lt;em&gt;Pending&lt;/em&gt; state for about four minutes in total.&lt;/p&gt;

&lt;p&gt;In case of multiple simultaneous AWS maintenance events, the Kubernetes scheduler would honour our &lt;a href=&quot;https://kubernetes.io/docs/tasks/run-application/configure-pdb/&quot;&gt;PodDisruptionBudget&lt;/a&gt; and not evict more than one Kafka pod at a time.&lt;/p&gt;

&lt;h3 id=&quot;dynamic-nlb-configuration&quot;&gt;Dynamic NLB configuration&lt;/h3&gt;

&lt;p&gt;To automatically map the NLB’s target groups with a newly spun up EC2 instance, we leveraged the &lt;a href=&quot;https://docs.aws.amazon.com/eks/latest/userguide/aws-load-balancer-controller.html&quot;&gt;AWS Load Balancer Controller&lt;/a&gt; (LBC).&lt;/p&gt;

&lt;p&gt;Let us see how it works.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/kafka-on-kubernetes/image6.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig. 4 Architecture of the LBC managing the NLB&apos;s target groups via TargetGroupBinding custom resources.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Fig. 4 shows how the LBC automates the reconfiguration of the NLB’s target groups:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It first retrieves the desired state described in Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&quot;&gt;custom resources&lt;/a&gt; (CR) of type &lt;a href=&quot;https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/guide/targetgroupbinding/targetgroupbinding&quot;&gt;TargetGroupBinding&lt;/a&gt;. There is one such resource per target group to maintain. Each TargetGroupBinding CR associates its respective target group with a Kubernetes service.&lt;/li&gt;
  &lt;li&gt;The LBC then watches over the changes of the Kubernetes services that are referenced in the TargetGroupBinding CRs’ definition, specifically the private IP addresses exposed by their respective &lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/#endpoints&quot;&gt;Endpoints resources&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;When a change is detected, it dynamically updates the corresponding NLB’s target groups with those IP addresses as well as the TCP port of the target containers (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;containerPort&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This automated design sets up the NLB’s target groups with IP addresses (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;targetType: ip&lt;/code&gt;) instead of EC2 instance IDs (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;targetType: instance&lt;/code&gt;). Although the LBC can handle both target types, the IP address approach is actually more straightforward in our case, since each pod has a routable private IP address in the AWS subnet, thanks to the &lt;a href=&quot;https://docs.aws.amazon.com/eks/latest/userguide/managing-vpc-cni.html&quot;&gt;AWS Container Networking Interface&lt;/a&gt; (CNI) plug-in.&lt;/p&gt;

&lt;p&gt;This dynamic NLB configuration design comes with a challenge. Whenever we need to update the Strimzi CR, the rollout of the change to each Kafka pod in a rolling update fashion is happening too fast for the NLB. This is because the NLB inherently takes some time to mark each target as healthy before enabling it. The Kafka brokers that have just been rolled out start advertising their broker-specific endpoints to the Kafka clients via the bootstrap service, but those 
endpoints are actually not immediately available because the NLB is still checking their health. To mitigate this, we have reduced the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HealthCheckIntervalSeconds&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HealthyThresholdCount&lt;/code&gt; parameters of each target group to their minimum values of 5 and 2 respectively. This reduces the maximum delay for the NLB to detect that a target has become healthy to 10 seconds. In addition, we have configured the LBC with a &lt;a href=&quot;https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/deploy/pod_readiness_gate/&quot;&gt;Pod Readiness Gate&lt;/a&gt;. This feature makes the Strimzi rolling deployment wait for the health check of the NLB to pass, before marking the current pod as &lt;em&gt;Ready&lt;/em&gt; and proceeding with the next pod.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/kafka-on-kubernetes/image7.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig. 5 Steps for a Strimzi rolling deployment with a Pod Readiness Gate. Only one Kafka broker and one NLB listener and target group are shown for simplicity.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Fig. 5 shows how the Pod Readiness Gate works during a Strimzi rolling deployment:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The old Kafka pod is terminated.&lt;/li&gt;
  &lt;li&gt;The new Kafka pod starts up and joins the Kafka cluster. Its individual endpoint for direct access via the NLB is immediately advertised by the Kafka cluster. However, at this stage, it is not reachable, as the target group of the NLB still points to the IP address of the old Kafka pod.&lt;/li&gt;
  &lt;li&gt;The LBC updates the target group of the NLB with the IP address of the new Kafka pod, but the NLB health check has not yet passed, so the traffic is not forwarded to the new Kafka pod just yet.&lt;/li&gt;
  &lt;li&gt;The LBC then waits for the NLB health check to pass, which takes 10 seconds. Once the NLB health check has passed, the NLB resumes forwarding the traffic to the Kafka pod.&lt;/li&gt;
  &lt;li&gt;Finally, the LBC updates the pod readiness gate of the new Kafka pod. This informs Strimzi that it can proceed with the next pod of the rolling deployment.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;data-persistence-with-ebs&quot;&gt;Data persistence with EBS&lt;/h3&gt;

&lt;p&gt;To address the challenge of the residual PV and PVC of the old worker node preventing Kubernetes from mounting the local storage of the new worker node after a node rotation, we adopted &lt;a href=&quot;https://aws.amazon.com/ebs/&quot;&gt;Elastic Block Store&lt;/a&gt; (EBS) volumes instead of NVMe instance store volumes. Contrary to the latter, EBS volumes can conveniently be attached and detached. The trade-off is that their performance is significantly lower.&lt;/p&gt;

&lt;p&gt;However, relying on EBS comes with additional benefits:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The cost per GB is lower, compared to NVMe instance store volumes.&lt;/li&gt;
  &lt;li&gt;Using EBS decouples the size of an instance in terms of CPU and memory from its storage capacity, leading to further cost savings by independently right-sizing the instance type and its storage. Such a separation of concerns also opens the door to new use cases requiring disproportionate amounts of storage.&lt;/li&gt;
  &lt;li&gt;After a worker node rotation, the time needed for the new node to get back in sync is faster, as it only needs to catch up the data that was produced during the downtime. This leads to shorter maintenance operations and higher iteration speed. Incidentally, the associated inter-AZ traffic cost is also lower, since there is less data to transfer among brokers during this time.&lt;/li&gt;
  &lt;li&gt;Increasing the storage capacity is an online operation.&lt;/li&gt;
  &lt;li&gt;Data backup is supported by taking snapshots of EBS volumes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have verified with our historical monitoring data that the performance of &lt;a href=&quot;https://aws.amazon.com/ebs/general-purpose/&quot;&gt;EBS General Purpose 3&lt;/a&gt; (gp3) volumes is significantly above our maximum historical values for both throughput and I/O per second (IOPS), and we have successfully benchmarked a test EBS-based Kafka cluster. We have also set up new monitors to be alerted in case we need to 
provision either additional throughput or IOPS, beyond the baseline of EBS gp3 volumes.&lt;/p&gt;

&lt;p&gt;With that, we updated our instance types from storage optimised instances to either general purpose or memory optimised instances. We added the &lt;a href=&quot;https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html&quot;&gt;Amazon EBS Container Storage Interface (CSI) driver&lt;/a&gt; to the Kubernetes cluster and created a new Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/storage-classes/&quot;&gt;storage class&lt;/a&gt; to let the cluster dynamically provision EBS gp3 volumes.&lt;/p&gt;

&lt;p&gt;We configured Strimzi to use that storage class to create any new PVCs. This makes Strimzi able to automatically create the EBS volumes it needs, typically when the cluster is first set up, but also to attach/detach the volumes to/from the EC2 instances whenever a Kafka pod is relocated to a different worker node.&lt;/p&gt;

&lt;p&gt;Note that the EBS volumes are not part of any ASG &lt;a href=&quot;https://docs.aws.amazon.com/autoscaling/ec2/userguide/launch-templates.html&quot;&gt;Launch Template&lt;/a&gt;, nor do they scale automatically with the ASGs.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/kafka-on-kubernetes/image3.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig. 6 Steps for the Strimzi Operator to create an EBS volume and attach it to a new Kafka pod.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Fig. 6 illustrates how this works when Strimzi sets up a new Kafka broker, for example the first broker of the cluster in the initial setup:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;a href=&quot;https://strimzi.io/docs/operators/latest/overview#overview-components-cluster-operator-str&quot;&gt;Strimzi Cluster Operator&lt;/a&gt; first creates a new PVC, specifying a volume size and EBS gp3 as its storage class. The storage class is configured with the EBS CSI Driver as the volume provisioner, so that volumes are dynamically provisioned &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt;. However, because it is also set up with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volumeBindingMode: WaitForFirstConsumer&lt;/code&gt;, the volume is not yet provisioned until a pod actually claims the PVC.&lt;/li&gt;
  &lt;li&gt;The Strimzi Cluster Operator then creates the Kafka pod, with a reference to the newly created PVC. The pod is scheduled to start, which in turn claims the PVC.&lt;/li&gt;
  &lt;li&gt;This triggers the EBS CSI Controller. As the volume provisioner, it dynamically creates a new EBS volume in the AWS VPC, in the AZ of the worker node where the pod has been scheduled to start.&lt;/li&gt;
  &lt;li&gt;It then attaches the newly created EBS volume to the corresponding EC2 instance.&lt;/li&gt;
  &lt;li&gt;After that, it creates a Kubernetes PV with &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/persistent-volumes/#node-affinity&quot;&gt;nodeAffinity&lt;/a&gt; and &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume&quot;&gt;claimRef&lt;/a&gt; specifications, making sure that the PV is reserved for the Kafka broker 1 pod.&lt;/li&gt;
  &lt;li&gt;Lastly, it updates the PVC with the reference of the newly created PV. The PVC is now in &lt;em&gt;Bound&lt;/em&gt; state and the Kafka pod can start.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One important point to take note of is that EBS volumes can only be attached to EC2 instances residing in their own AZ. Therefore, when rotating a worker node, the EBS volume can only be re-attached to the new instance if both old and new instances reside in the same AZ. A simple way to guarantee this is to set up one ASG per AZ, instead of a single ASG spanning across 3 AZs.&lt;/p&gt;

&lt;p&gt;Also, when such a rotation occurs, the new broker only needs to synchronise the recent data produced during the brief downtime, which is typically an order of magnitude faster than replicating the entire volume (depending on the overall retention period of the hosted Kafka topics).&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
&lt;caption style=&quot;text-align:center&quot;&gt;Table 1 Comparison of the resynchronization of the Kafka data after a broker rotation between the initial design and the new design with EBS volumes.&lt;/caption&gt;
&lt;thead&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;Initial design (NVMe instance store volumes)&lt;/th&gt;
    &lt;th&gt;New design (EBS volumes)&lt;/th&gt;
  &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
    &lt;td&gt;Data to synchronise&lt;/td&gt;
    &lt;td&gt;All of the data&lt;/td&gt;
    &lt;td&gt;Recent data produced during the brief downtime&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Function of (primarily)&lt;/td&gt;
    &lt;td&gt;Retention period&lt;/td&gt;
    &lt;td&gt;Downtime&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Typical duration&lt;/td&gt;
    &lt;td&gt;Hours&lt;/td&gt;
    &lt;td&gt;Minutes&lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;outcome&quot;&gt;Outcome&lt;/h2&gt;

&lt;p&gt;With all that, let us revisit the initial scenario, where a malfunctioning worker node is being replaced by a fresh new node.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;&lt;figure&gt;
  &lt;img src=&quot;/img/kafka-on-kubernetes/image1.png&quot; alt=&quot;&quot; style=&quot;width:80%&quot; /&gt;&lt;figcaption align=&quot;middle&quot;&gt;Fig. 7 Representation of a worker node termination after implementing the solution. Node C is terminated and replaced by node D. This time, the Kafka broker 3 pod is able to start and serve traffic.&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Fig. 7 shows the worker node C being terminated and replaced (by the ASG) by a new worker node D, similar to what we have described in the initial problem statement. The worker node D automatically joins the Kubernetes cluster on start-up.&lt;/p&gt;

&lt;p&gt;However, this time, a seamless failover takes place:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The Kafka clients that were in the middle of producing or consuming to/from the partition leaders of Kafka broker 3 are gracefully redirected to Kafka brokers 1 and 2, where Kafka has migrated the leadership of its leader partitions.&lt;/li&gt;
  &lt;li&gt;The target groups of the NLB for both the bootstrap connection and Kafka broker 3 are automatically updated by the LBC. The connectivity between the NLB and Kafka broker 3 is immediately restored.&lt;/li&gt;
  &lt;li&gt;Triggered by the creation of the Kafka broker 3 pod, the Amazon EBS CSI driver running on the worker node D re-attaches the EBS volume 3 that was previously attached to the worker node C, to the worker node D instead. This enables Kubernetes to automatically re-bind the corresponding PV and PVC to Kafka broker 3 pod. With its storage dependency resolved, Kafka broker 3 is able to start successfully and re-join the Kafka cluster. From there, it only needs to catch up with the new data that was produced 
during its short downtime, by replicating it from Kafka brokers 1 and 2.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With this fault-tolerant design, when an EC2 instance is being retired by AWS, no particular action is required from our end.&lt;/p&gt;

&lt;p&gt;Similarly, our EKS version upgrades, as well as any operations that require rotating all worker nodes of the cluster in general, are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Simpler and less error-prone&lt;/strong&gt;: We only need to rotate each instance in sequence, with no need for manually reconfiguring the target groups of the NLB and deleting the zombie PVCs anymore.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Faster&lt;/strong&gt;: The time between each instance rotation is limited to the short amount of time it takes for the restarted Kafka broker to catch up with the new data.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;More cost-efficient&lt;/strong&gt;: There is less data to transfer across AZs (which is charged by AWS).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is worth noting that we have chosen to omit Zookeeper and Cruise Control in this article, for the sake of clarity and simplicity. In reality, all pods in the Kubernetes cluster - including Zookeeper and Cruise Control - now benefit from the same graceful stop, triggered by the AWS termination events and the NTH. Similarly, the EBS CSI driver improves the fault tolerance of any pods that use EBS volumes for persistent storage, which includes the Zookeeper pods.&lt;/p&gt;

&lt;h2 id=&quot;challenges-faced&quot;&gt;Challenges faced&lt;/h2&gt;

&lt;p&gt;One challenge that we are facing with this design lies in the EBS volumes’ management.&lt;/p&gt;

&lt;p&gt;On the one hand, the size of EBS volumes cannot be increased consecutively before the end of a cooldown period (minimum of 6 hours and can exceed 24 hours in some cases &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;). Therefore, when we need to urgently extend some EBS volumes because the size of a Kafka topic is suddenly growing, we need to be relatively generous when sizing the new required capacity and add a comfortable security margin, to make sure that we are not running out of storage in the short run.&lt;/p&gt;

&lt;p&gt;On the other hand, shrinking a Kubernetes PV is not a supported operation. This can affect the cost efficiency of our design if we overprovision the storage capacity by too much, or in case the workload of a particular cluster organically diminishes.&lt;/p&gt;

&lt;p&gt;One way to mitigate this challenge is to tactically scale the cluster horizontally (ie. adding new brokers) when there is a need for more storage and the existing EBS volumes are stuck in a cooldown period, or when the new storage need is only temporary.&lt;/p&gt;

&lt;h2 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h2&gt;

&lt;p&gt;In the future, we can improve the NTH’s capability by utilising webhooks. Upon receiving events from SQS, the NTH can also forward the events to the specified webhook URLs.&lt;/p&gt;

&lt;p&gt;This can potentially benefit us in a few ways, e.g.:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Proactively spinning up a new instance without waiting for the old one to be terminated, whenever a termination event is received. This would shorten the rotation time even further.&lt;/li&gt;
  &lt;li&gt;Sending Slack notifications to Coban engineers to keep them informed of any actions taken by the NTH.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We would need to develop and maintain an application that receives webhook events from the NTH and performs the necessary actions.&lt;/p&gt;

&lt;p&gt;In addition, we are also rolling out &lt;a href=&quot;https://karpenter.sh/&quot;&gt;Karpenter&lt;/a&gt; to replace the Kubernetes Cluster Autoscaler, as it is able to spin up new instances slightly faster, helping reduce the four minutes delay a Kafka pod remains in &lt;em&gt;Pending&lt;/em&gt; state during a node rotation. Incidentally, Karpenter also removes the need for setting up one ASG by AZ, as it is able to deterministically provision instances in a specific AZ, for example where a particular EBS volume resides.&lt;/p&gt;

&lt;p&gt;Lastly, to ensure that the performance of our EBS gp3 volumes is both sufficient and cost-efficient, we want to explore autoscaling their throughput and IOPS beyond the baseline, based on the usage metrics collected by our monitoring stack.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a name=&quot;1&quot; href=&quot;#1&quot;&gt;[1]&lt;/a&gt; &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/&quot;&gt;Dynamic Volume Provisioning | Kubernetes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;2&quot; href=&quot;#2&quot;&gt;[2]&lt;/a&gt; &lt;a href=&quot;https://repost.aws/knowledge-center/ebs-volume-stuck-optimizing-on-modification&quot;&gt;Troubleshoot EBS volume stuck in Optimizing state during modification | AWS re:Post&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;small class=&quot;credits&quot;&gt;We would like to thank our team members and Grab Kubernetes gurus that helped review and improve this blog before publication: Will Ho, Gable Heng, Dewin Goh, Vinnson Lee, Siddharth Pandey, Shi Kai Ng, Quang Minh Tran, Yong Liang Oh, Leon Tay, Tuan Anh Vu. &lt;/small&gt;&lt;/p&gt;

&lt;h1 id=&quot;join-us&quot;&gt;Join us&lt;/h1&gt;

&lt;p&gt;Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.&lt;/p&gt;

&lt;p&gt;Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, &lt;a href=&quot;https://grab.careers/&quot;&gt;join our team&lt;/a&gt; today!&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Dec 2023 00:10:10 +0000</pubDate>
        <link>https://engineering.grab.com/kafka-on-kubernetes</link>
        <guid isPermaLink="true">https://engineering.grab.com/kafka-on-kubernetes</guid>
        
        <category>Kafka</category>
        
        <category>Kubernetes</category>
        
        <category>AWS</category>
        
        <category>Data Streaming</category>
        
        
        <category>Engineering</category>
        
        <category>Data Science</category>
        
      </item>
    
  </channel>
</rss>
