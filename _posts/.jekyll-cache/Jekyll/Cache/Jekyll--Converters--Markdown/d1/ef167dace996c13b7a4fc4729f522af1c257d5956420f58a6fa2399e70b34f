I"N‰<p>A couple of weeks ago, we had a production outage for one of our internal Ruby on Rails application servers. One of the databases that the application connects to had a failover event. It was expected that the server should continue functioning for endpoints which do not depend on this database, but it was observed that our server slowed down to a crawl, and was unable to function properly even after the failover completed, until we manually restarted the servers.</p>

<h2 id="background">Background</h2>

<p><a href="http://guides.rubyonrails.org/active_record_basics.html">ActiveRecord</a> is the canonical ORM for Rails to access a database. Different requests are handled on different threads, so a connection pool is necessary to maintain a limited set of connections to the database and also to skip the additional latency of establishing a TCP connection.</p>

<blockquote>
  <p>A connection pool synchronises thread access to a limited number of database connections. The basic idea is that each thread checks out a database connection from the pool, uses that connection, and checks the connection back in.</p>
</blockquote>

<blockquote>
  <p>It will also handle cases in which there are more threads than connections: if all connections have been checked out, and a thread tries to checkout a connection anyway, then ConnectionPool will wait until some other thread has checked in a connection.</p>
</blockquote>

<p>Source: The <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html"><code class="language-plaintext highlighter-rouge">ActiveRecord::Connection Pool</code></a> .</p>

<h3 id="options-for-the-connection-pool">Options for the Connection Pool</h3>

<p>In Rails, database configurations are set in the <code class="language-plaintext highlighter-rouge">config/database.yml</code> file. These options are either native to the <code class="language-plaintext highlighter-rouge">ActiveRecord::ConnectionPool</code> module, or passed to the underlying adapter, depending on whether MySQL or PostgreSQL is used.</p>

<p>ActiveRecord uses connection adapters to make database calls. For MySQL, it uses the <a href="https://github.com/brianmario/mysql2">mysql2</a> library, which depends on the <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-implementations.html"><code class="language-plaintext highlighter-rouge">libmysqlclient</code></a> C library. The following options affect the behaviour of the library:</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th>Option</th>
      <th>Description</th>
      <th>Source</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pool</code></td>
      <td>This specifies the maximum number of connections to the database that ActiveRecord will maintain per server.</td>
      <td>Native to the <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html">ActiveRecord ConnectionPool</a></td>
      <td>5 <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html#class-ActiveRecord::ConnectionAdapters::ConnectionPool-label-Options">Source</a></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">checkout_timeout</code></td>
      <td>When making a ActiveRecord call, ActiveRecord tries to checkout a database connection from the pool. If the pool is at maximum capacity, ActiveRecord will wait for this timeout to elapse before raising an <code class="language-plaintext highlighter-rouge">ActiveRecord</code> <code class="language-plaintext highlighter-rouge">ConnectionTimeoutError</code> exception.</td>
      <td>Native to the <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html">ActiveRecord ConnectionPool</a></td>
      <td>5 seconds <a href="https://github.com/rails/rails/blob/e5dc756bf9424086c403d1025971c3e704e1dcfa/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L328">Source</a>.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">connect_timeout</code></td>
      <td>If there are no available connections to the database in the connection pool, a new connection will have to be established. <code class="language-plaintext highlighter-rouge">connect_timeout</code>, specifies the timeout to establish a new connection to the database before failing.</td>
      <td>Native to the <a href="https://github.com/brianmario/mysql2">mysql2</a> library, passed to <code class="language-plaintext highlighter-rouge">libmysqlclient</code> as <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-options.html"><code class="language-plaintext highlighter-rouge">MYSQL_OPT_CONNECT_TIMEOUT</code></a></td>
      <td>120 seconds <a href="https://github.com/brianmario/mysql2/blob/a1c198ee4c8d4d32dfa79f207ec7d0524c5f7bcc/lib/mysql2/client.rb#L31">Source</a>.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">read_timeout</code></td>
      <td>Read timeout is used by the <code class="language-plaintext highlighter-rouge">libmysqlclient</code> library to identify whether the MySQL client is still alive and sending data. As we know that TCP sends data in chunks, the client waits for this timeout when reading from the socket, before deeming that there is an error and closing the connection.</td>
      <td>Native to the <a href="https://github.com/brianmario/mysql2">mysql2</a> library, passed to <code class="language-plaintext highlighter-rouge">libmysqlclient</code> as <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-options.html"><code class="language-plaintext highlighter-rouge">MYSQL_OPT_READ_TIMEOUT</code></a></td>
      <td>3 Ã— 10 minutes <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-options.html">Source</a></td>
    </tr>
  </tbody>
</table>

<h3 id="connection-pooling-algorithm">Connection Pooling Algorithm</h3>

<p>The following pseudocode is the algorithm for how ActiveRecord retrieves connections from the pool to perform database queries.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">existing</span> <span class="n">connections</span> <span class="n">to</span> <span class="n">the</span> <span class="n">database</span> <span class="n">available</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">existing</span> <span class="n">connections</span>

<span class="k">if</span> <span class="n">the</span> <span class="n">pool</span> <span class="ow">is</span> <span class="n">at</span> <span class="n">capacity</span><span class="p">:</span>
    <span class="n">wait</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span><span class="p">,</span> <span class="k">raise</span> <span class="n">exception</span> <span class="k">if</span> <span class="sb">`checkout_timeout`</span> <span class="n">has</span> <span class="n">elapsed</span>
    <span class="k">return</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">now</span> <span class="n">available</span> <span class="n">connections</span>

<span class="c1"># pool is not at capacity
</span><span class="k">try</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">connection</span><span class="p">,</span> <span class="k">raise</span> <span class="n">exception</span> <span class="k">if</span> <span class="sb">`connect_timeout`</span> <span class="n">has</span> <span class="n">elapsed</span>

<span class="c1"># connection to database established
</span><span class="k">return</span> <span class="n">new</span> <span class="n">connection</span>
</code></pre></div></div>

<p>This is loosely translated from the <a href="https://github.com/rails/rails/blob/f8c00c130016b248d1d409f131356632dcc418c6/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L725-L749">source code</a>.</p>

<h2 id="replicating-and-debugging">Replicating and Debugging</h2>

<p>Letâ€™s try to replicate the problem in a small Rails application. We will create a new Rails application, connect it to a database, run it in a Docker container and finally run some experiments to replicate the problem. In production, we use <a href="https://github.com/puma/puma">Puma</a> to run our Rails server and connect to a few MySQL databases managed by <a href="https://aws.amazon.com/rds/">Amazon Relational Database Service (RDS)</a>, so we will try to follow that on our local setup.</p>

<h3 id="step-1-create-a-new-rails-application">Step 1: Create a New Rails Application</h3>

<p>First, we will scaffold a fresh Rails application and connect it to two databases that we will call as <code class="language-plaintext highlighter-rouge">db_main</code> and <code class="language-plaintext highlighter-rouge">db_other</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># the flags removes unwanted boilerplate code</span>
rails new rails-mysql-timeouts <span class="nt">--database</span><span class="o">=</span>mysql <span class="nt">--api</span> <span class="nt">-M</span> <span class="nt">-C</span> <span class="nt">-S</span> <span class="nt">-J</span> <span class="nt">-T</span>
</code></pre></div></div>

<p>For simplicity, we will set the <code class="language-plaintext highlighter-rouge">thread_count</code> of our Puma server to <code class="language-plaintext highlighter-rouge">2</code>, in <code class="language-plaintext highlighter-rouge">config/puma.rb</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">threads_count</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">rails generate scaffold</code>, we set up a <code class="language-plaintext highlighter-rouge">Driver</code> model to talk to our main database, and a <code class="language-plaintext highlighter-rouge">Passenger</code> model to talk to another database we want to test the failure on. This can be done by adding the following line to our <code class="language-plaintext highlighter-rouge">Passengers</code> model.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Passenger</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="c1"># connect to #{Rails.env}_other database specified in the database.yml</span>
  <span class="n">establish_connection</span> <span class="s2">"</span><span class="si">#{</span><span class="no">Rails</span><span class="p">.</span><span class="nf">env</span><span class="si">}</span><span class="s2">_other"</span><span class="p">.</span><span class="nf">to_sym</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We now have the following HTTP routes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># connects to db_main
GET /drivers/1

# connects to db_other
GET /passengers/1
</code></pre></div></div>

<p>Now, we will run our Rails server with the following environment variables:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">RAILS_ENV</span><span class="o">=</span>production
<span class="nb">export </span><span class="nv">RAILS_LOG_TO_STDOUT</span><span class="o">=</span>1

rails server
</code></pre></div></div>

<p>By using a docker container to run the Rails application, we can isolate the process namespace and focus directly on our application. We run <code class="language-plaintext highlighter-rouge">ps</code> and observe the two threads we have configured puma â€” <code class="language-plaintext highlighter-rouge">puma 001</code> and <code class="language-plaintext highlighter-rouge">puma 002</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ps <span class="nt">-T</span> <span class="nt">-e</span>
  PID  SPID TTY          TIME CMD
    1     1 ?        00:00:00 <span class="nb">sleep
   </span>30    30 pts/1    00:00:00 bash
   63    63 pts/0    00:00:00 bash
   97    97 pts/1    00:00:03 ruby
   97    99 pts/1    00:00:00 ruby-timer-thr
   97   105 pts/1    00:00:00 tmp_restart.rb<span class="k">*</span>
   97   106 pts/1    00:00:00 puma 001
   97   107 pts/1    00:00:00 puma 002
   97   108 pts/1    00:00:00 reactor.rb:152
   97   109 pts/1    00:00:00 thread_pool.rb<span class="k">*</span>
   97   110 pts/1    00:00:00 thread_pool.rb<span class="k">*</span>
   97   111 pts/1    00:00:00 server.rb:327
  112   112 pts/0    00:00:00 ps
</code></pre></div></div>

<p>Note that PID 1 is <code class="language-plaintext highlighter-rouge">sleep</code> because in <a href="https://github.com/grab/blogs/tree/master/2017-01-29-deep-dive-into-database-timeouts-in-rails/docker-compose.yml"><code class="language-plaintext highlighter-rouge">docker-compose.yml</code></a>, we specified that the container should start with <code class="language-plaintext highlighter-rouge">cmd: sleep infinity</code> so that we can attach to the running container at any time, not unlike a <code class="language-plaintext highlighter-rouge">ssh</code> to a machine.</p>

<h3 id="step-2-verify-our-application">Step 2: Verify Our Application</h3>

<p>We make the following requests to ensure that our server is working correctly:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl localhost:3000/drivers
<span class="o">[{</span><span class="s2">"id"</span>:1,<span class="s2">"name"</span>:<span class="s2">"test driver"</span>,<span class="s2">"created_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span>,<span class="s2">"updated_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span><span class="o">}]</span>

<span class="nv">$ </span>curl localhost:3000/passengers
<span class="o">[{</span><span class="s2">"id"</span>:1,<span class="s2">"name"</span>:<span class="s2">"test"</span>,<span class="s2">"created_at"</span>:<span class="s2">"2017-01-01T00:00:00.000Z"</span>,<span class="s2">"updated_at"</span>:<span class="s2">"2017-01-07T00:00:00.000Z"</span><span class="o">}]</span>
</code></pre></div></div>

<p>Great! We are now able to see the records generated in the database by the above curl requests.</p>

<p>The entire source code for this application can be found <a href="https://github.com/grab/blogs/tree/master/2017-01-29-deep-dive-into-database-timeouts-in-rails">here</a>.</p>

<h3 id="step-3-simulating-the-production-issue">Step 3: Simulating the Production Issue</h3>

<p>We will now try to simulate the production issue by using a proxy to monitor all our TCP connections from our Rails application to our database. Finally, we will run some experiments by sending requests that hit the backend database and analyse the behaviour of both <code class="language-plaintext highlighter-rouge">connect_timeout</code> and <code class="language-plaintext highlighter-rouge">read_timeout</code> settings.</p>

<p>First, we use <a href="https://github.com/Shopify/toxiproxy">Toxiproxy</a> as a transport layer proxy to <code class="language-plaintext highlighter-rouge">db_other</code> which allows us to manipulate the pipe between the client and the upstream database. The following command stops all data from getting the proxy, and closes the connection after timeout.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>toxiproxy-cli toxic add db_other_proxy <span class="nt">--toxicName</span> <span class="nb">timeout</span> <span class="nt">--type</span> <span class="nb">timeout</span> <span class="nt">--attribute</span><span class="o">=</span><span class="nb">timeout</span><span class="o">=</span>100000
</code></pre></div></div>

<p>Now we test if things are still working for endpoints that access the unaffected database.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl localhost:3000/drivers
<span class="o">[{</span><span class="s2">"id"</span>:1,<span class="s2">"name"</span>:<span class="s2">"test driver"</span>,<span class="s2">"created_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span>,<span class="s2">"updated_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span><span class="o">}]</span>
</code></pre></div></div>

<p>This is expected, as the <code class="language-plaintext highlighter-rouge">db_main</code> is still running. Letâ€™s trigger a request to <code class="language-plaintext highlighter-rouge">db_other</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl localhost:3000/passengers
</code></pre></div></div>

<p>We notice that the command does not exit and our terminal blocks while waiting for the command to terminate.</p>

<p>Letâ€™s trigger another call to <code class="language-plaintext highlighter-rouge">db_main</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl localhost:3000/drivers
<span class="o">[{</span><span class="s2">"id"</span>:1,<span class="s2">"name"</span>:<span class="s2">"test driver"</span>,<span class="s2">"created_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span>,<span class="s2">"updated_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span><span class="o">}]</span>
</code></pre></div></div>

<p>Seems like it still works! Now letâ€™s make another request to the <code class="language-plaintext highlighter-rouge">db_other</code> to lock up the two threads our server is configured to use.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl localhost:3000/passengers
</code></pre></div></div>

<p>And make another request to <code class="language-plaintext highlighter-rouge">db_main</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl localhost:3000/drivers
</code></pre></div></div>

<p>Notice that the call to <code class="language-plaintext highlighter-rouge">/drivers</code> is stuck and does not complete now. Because we have set the thread count to <code class="language-plaintext highlighter-rouge">2</code>, and have two <code class="language-plaintext highlighter-rouge">/passengers</code> requests in flight, both threads are stuck waiting for the database and we do not have any more threads available to handle the new request, hence the stalled <code class="language-plaintext highlighter-rouge">/drivers</code> request.</p>

<p>This is exactly what happened during our production outage, except on a much larger scale.</p>

<h3 id="experiments">Experiments</h3>

<p>Letâ€™s perform some experiments to better understand how <code class="language-plaintext highlighter-rouge">connect_timeout</code> and <code class="language-plaintext highlighter-rouge">read_timeout</code> work. We will set the timeouts to the following:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">+ connect_timeout</span><span class="pi">:</span> <span class="m">10</span>
<span class="s">+ read_timeout</span><span class="pi">:</span> <span class="m">5</span>
</code></pre></div></div>

<p>In the following section, we will perform two experiments.</p>

<h4 id="experiment-1-application-has-no-existing-connections-before-database-failure">Experiment 1: Application has No Existing Connections before Database Failure</h4>

<ol>
  <li>Stop data transmission to <code class="language-plaintext highlighter-rouge">db_other</code></li>
  <li>Start Rails</li>
  <li><code class="language-plaintext highlighter-rouge">GET /passengers</code></li>
</ol>

<p>We first block data to <code class="language-plaintext highlighter-rouge">db_other</code> , so that on the first ActiveRecord call to retrieve some data from the database, there are no available connections in the connection pool and it needs to establish a fresh connection to the database when it receives the first <code class="language-plaintext highlighter-rouge">GET /passengers</code> request.</p>

<h4 id="experiment-2-application-has-existing-connections-before-database-failure">Experiment 2: Application has Existing Connections before Database Failure</h4>

<ol>
  <li>Start Rails</li>
  <li><code class="language-plaintext highlighter-rouge">GET /passengers</code></li>
  <li>Stop data transmission to <code class="language-plaintext highlighter-rouge">db_other</code></li>
  <li><code class="language-plaintext highlighter-rouge">GET /passengers</code></li>
</ol>

<p>Weâ€™ve started Rails and made a call to <code class="language-plaintext highlighter-rouge">GET /passengers</code>. A connection to the database is established to retrieve the data, and checked back into the pool as an available connection after the request.</p>

<p>Now, when the proxy stops sending data to <code class="language-plaintext highlighter-rouge">db_other</code>, ActiveRecord does not know that the database is unavailable and believes that the previously checked in connection is available for use with the second <code class="language-plaintext highlighter-rouge">GET /passengers</code>.</p>

<p>We can use the <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code class="language-plaintext highlighter-rouge">ss</code></a> command to observe the TCP connections. When Rails has just been started, there are no existing TCP connections .</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># shows TCP connections with the PID</span>
<span class="nv">$ </span>ss <span class="nt">-tnp</span>
</code></pre></div></div>

<p>After a <code class="language-plaintext highlighter-rouge">GET /passengers</code> completes, a TCP connection can be seen in the <code class="language-plaintext highlighter-rouge">ESTAB</code> state.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ss <span class="nt">-tnp</span>
State  Recv-Q  Send-Q  Local Address:Port  Peer Address:Port
ESTAB  0       0       172.18.0.4:54304    172.18.0.3:3306   <span class="nb">users</span>:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>13<span class="o">))</span>
</code></pre></div></div>

<p>Now, we stop the database and make another call to <code class="language-plaintext highlighter-rouge">GET /passengers</code>. We run <code class="language-plaintext highlighter-rouge">ss</code> when the request is in flight, and observe another TCP connection for the request to the port Rails listens on, port <code class="language-plaintext highlighter-rouge">3000</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ss <span class="nt">-tnp</span>
State  Recv-Q  Send-Q  Local Address:Port  Peer Address:Port
ESTAB  0       0       172.18.0.4:54304    172.18.0.3:3306   <span class="nb">users</span>:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>13<span class="o">))</span>
ESTAB  0       0       172.18.0.4:3000     172.18.0.1:60878  <span class="nb">users</span>:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>12<span class="o">))</span>
</code></pre></div></div>

<p>After <code class="language-plaintext highlighter-rouge">read_timeout</code> has elapsed, we see that a new connection is established to the database, and the first one has transitioned to a <code class="language-plaintext highlighter-rouge">FIN-WAIT</code> state. This new TCP connection is in the <code class="language-plaintext highlighter-rouge">ESTAB</code> state (line 3), because we have only stopped the database on the application layer, but the sockets to the container still accept the TCP handshake on the transport layer.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ss <span class="nt">-tnp</span>
State       Recv-Q  Send-Q  Local Address:Port  Peer Address:Port
FIN-WAIT-2  0       0       172.18.0.4:54304    172.18.0.3:3306
ESTAB       0       0       172.18.0.4:54308    172.18.0.3:3306   <span class="nb">users</span>:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>13<span class="o">))</span>
ESTAB       0       0       172.18.0.4:3000     172.18.0.1:60878  <span class="nb">users</span>:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>12<span class="o">))</span>
</code></pre></div></div>

<p>After <code class="language-plaintext highlighter-rouge">connect_timeout</code> has elapsed, the request terminates with a 500 error, and we observe that all the connections are in the <code class="language-plaintext highlighter-rouge">FIN-WAIT</code> state.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ss <span class="nt">-tnp</span>
State       Recv-Q  Send-Q  Local Address:Port  Peer Address:Port
FIN-WAIT-2  0       0       172.18.0.4:54310    172.18.0.3:3306
FIN-WAIT-2  0       0       172.18.0.4:54304    172.18.0.3:3306
FIN-WAIT-2  0       0       172.18.0.4:54308    172.18.0.3:3306
</code></pre></div></div>

<p>The experimental data can be found <a href="#experimental-data">below</a>.</p>

<h4 id="findings">Findings</h4>

<p>Itâ€™s worth noting that when setting <code class="language-plaintext highlighter-rouge">connect_timeout</code> and <code class="language-plaintext highlighter-rouge">read_timeout</code> in the <code class="language-plaintext highlighter-rouge">database.yml</code>, there is a difference between empty values and the case where the key is missing entirely in the file. If the values are empty, scenario 1 will fail to terminate after 5 minutes, but if the keys are absent, scenario 1 will fail after 120 seconds, which is the default for <code class="language-plaintext highlighter-rouge">connect_timeout</code>.</p>

<h5 id="experiment-1-findings">Experiment 1 Findings</h5>

<p>The request waits for <code class="language-plaintext highlighter-rouge">connect_timeout</code> to connect to the database, where the default value (when not specified) is indeed 120 seconds.</p>

<p>As expected, connecting to the database with no existing connections is independent of the <code class="language-plaintext highlighter-rouge">read_timeout</code>.</p>

<h5 id="experiment-2-findings">Experiment 2 Findings</h5>

<p>The request waits for <code class="language-plaintext highlighter-rouge">read_timeout</code> + <code class="language-plaintext highlighter-rouge">connect_timeout</code> before failing. This is because the connection pool waits for <code class="language-plaintext highlighter-rouge">read_timeout</code> on the existing connection before terminating it, and then waits for <code class="language-plaintext highlighter-rouge">connect_timeout</code> as it tries to establish a new connection to <code class="language-plaintext highlighter-rouge">db_other</code>.</p>

<h2 id="analysis">Analysis</h2>

<p>With these findings, we can try to understand how the lack of these timeouts affected our Rails server in production during and after the database failover.</p>

<h3 id="establishing-terms">Establishing Terms</h3>

<p>Our application server constantly receives requests, out of which a certain percentage of requests will trigger the code to connect to the affected database, which weâ€™ll call <em>x</em>-type requests. The other requests, that do not trigger a database connection, weâ€™ll call <em>xâ€™</em>-type requests.</p>

<h3 id="analysis-1">Analysis</h3>

<p>With the background knowledge gathered in our experiments, letâ€™s try to analyse all the steps that happened during our production outage.</p>

<ol>
  <li>Rails started from a clean state, with no connections set up to the database initially</li>
  <li>Rails handles the first few <em>x</em> request types, opens a connection to the database</li>
  <li>Subsequent requests of <em>x</em> type can reuse the same connections from the connection pool</li>
  <li>At a certain time, due to a hardware fault out of our control, a failover of the database is triggered</li>
  <li>At the same time requests of <em>x</em> type comes in â€” and ActiveRecord reuses the same database connection from the pool, but there is no response. It then waits for <code class="language-plaintext highlighter-rouge">read_timeout</code>, causing the thread to be stuck waiting for the default timeout</li>
  <li>Even though Rails can process requests of the <em>xâ€™</em> type normally, more and more requests of <em>x</em> type come in and cause more and more threads to be stuck waiting</li>
  <li>Eventually, all the available threads to handle requests are stuck waiting on the TCP connection to the failed database, and Rails can no longer respond to new requests</li>
  <li>After the default <code class="language-plaintext highlighter-rouge">read_timeout</code> has elapsed (3 Ã— 10 minutes), some threads will be released to handle new requests</li>
  <li>Subsequent requests of <em>x</em> type will cause a new connection to be opened to the database
    <ul>
      <li>If the failover is complete and the DNS records for the new instance has been updated, the new connections will be established</li>
      <li>If the failover is not complete or the DNS records were not updated, the TCP connections will still try to connect to the old IP address with the failed database instance. The connections will wait for the <code class="language-plaintext highlighter-rouge">connect_timeout</code> (default 120 seconds) to elapse before failing</li>
    </ul>
  </li>
  <li>Finally, once all the threads are stuck, our Rails application stops responding to all requests until it was restarted manually</li>
</ol>

<h4 id="solution">Solution</h4>

<p>To fix the problem, we have to prevent our database connections from being stuck in trying to read from an unresponsive socket, and trying to connect to a closed socket.</p>

<p>This can be done by simply setting the <code class="language-plaintext highlighter-rouge">read_timeout</code> so that when the database fails, existing connections and threads will be released. The <code class="language-plaintext highlighter-rouge">connect_timeout</code> also has to be set so that when the existing connections are released, new connections and threads handling the requests will not be stuck trying to connect to the same unavailable database.</p>

<p>We set the following values in our staging environment and manually triggered a database failover via the AWS console, and observed that requests of the <em>xâ€™</em> type are no longer stalled during the failover.</p>

<p>The following is a snippet for our current <code class="language-plaintext highlighter-rouge">database.yml</code> configuration before the outage, and the changes to resolve the problem.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Config for the non-primary `db_other` database</span>
<span class="na">production_other</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">mysql2</span>
  <span class="na">encoding</span><span class="pi">:</span> <span class="s">utf8</span>
  <span class="na">reconnect</span><span class="pi">:</span> <span class="no">false</span>
  <span class="na">database</span><span class="pi">:</span> <span class="s">â€¦</span>
  <span class="na">pool</span><span class="pi">:</span> <span class="s">â€¦</span>
  <span class="na">reaping_frequency</span><span class="pi">:</span> <span class="m">120</span>
  <span class="na">username</span><span class="pi">:</span> <span class="s">â€¦</span>
  <span class="na">password</span><span class="pi">:</span> <span class="s">â€¦</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">â€¦</span>
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># New changes</span>
<span class="s">+ connect_timeout</span><span class="pi">:</span> <span class="m">5</span>
<span class="s">+ read_timeout</span><span class="pi">:</span> <span class="m">5</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>In this post, we have gone over how timeouts are handled by the ActiveRecord ORM with our MySQL database and how failing to configure them brought down some of our production systems.</p>

<p>Timeouts are very important configurations when setting up distributed systems and they are easily overlooked in the initial deployments of such applications.</p>

<p>These principles are not just limited to Rails or MySQL, and the experiments and their findings can be easily extended to other technologies as well. Needless to say, these timeout settings are extremely important for the resiliency of applications in the world of micro services.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts">ankane/the-ultimate-guide-to-ruby-timeouts</a></li>
  <li><a href="https://github.com/ankane/production_rails">ankane/production_rails</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-options.html">MySQL Reference Manual</a></li>
  <li><a href="https://github.com/zach14c/mysql/blob/mysql-5.7/include/mysql_com.h#L298">MySQL Source Code Mirror</a></li>
  <li><a href="https://blog.confirm.ch/tcp-connection-states/">TCP Connection States</a></li>
</ul>

<p>Big thanks to <a href="https://github.com/lowjoel">Joel Low</a> for helping out with this investigation and clarifying ambiguities in Rails and MySQL, and my manager Amit Saini for his helpful review of this post!</p>

<p>Source code for the test rails application can be found <a href="https://github.com/grab/blogs/tree/master/2017-01-29-deep-dive-into-database-timeouts-in-rails">here</a>.</p>
:ET