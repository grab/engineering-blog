I"™'<p>This is the second part of our series â€œDeep Dive into iOS Automation at Grabâ€, where we will cover how we manage continuous delivery. The first article is available <a href="/deep-dive-into-ios-automation-at-grab-integration-testing">here</a>.</p>

<p>As a common solution to the limitations of an Apple developer accountâ€™s device whitelist, we use an enterprise account to distribute beta apps internally. There are 4 build configurations per target:</p>

<p><strong>Adhoc QA -</strong> Most frequently distributed builds for mobile devs and QAs whose devices present in the ad hoc provisioning profile.</p>

<p><strong>Hot Dogfood -</strong> Similar to adhoc QA (both have debug options to connect to a staging environment) but signed under an enterprise account. This build is meant for backend devs to test out their APIs on staging.</p>

<p><strong>Dogfood -</strong> Company-wide beta testing that includes both the online and offline team. This is often released when new features are ready or accepted by QA. It can also be a release candidate before we submit to the App Store.</p>

<p><strong>Testflight -</strong> Production regression testing for QA team. The accepted build will be submitted to the App Store for release.</p>

<p>The first 3 are distributed through <a href="https://get.fabric.io/">Fabric</a>. The last one is, of course, distributed through iTunes Connect. Archiving is done simply through bash scripts. Why did we move away from Fastlane? First of all, our primary need is archiving. We donâ€™t really need a bunch of other powerful features. The scripts simply perform clean build and archive actions using <code class="language-plaintext highlighter-rouge">xcodebuild</code>. Each of them is less than 100 lines. Secondly, itâ€™s so much easier and flexible for us to customize our own script. E.g. final modifications to the code before archiving. Lastly, we have one less dependency. That means one less step to provision a new server.</p>

<h3 id="server-side-swift">Server-side Swift</h3>

<p>Now whenever we need a new build we simply execute a script. But the question is, who should do it? Itâ€™s clearly not an option to login to the build machine and do it manually. So again, as a whole bunch of in-house enthusiasts, we wrote a simple app using server-side Swift. The first version was implemented by our teammate <a href="https://github.com/mno2">Paul Meng</a>. It has gone through a few iterations over time.</p>

<p>The app integrates with <a href="https://github.com/pvzig/SlackKit.git">SlackKit</a> using Swift Package Manager and listens to the command from a Slackbot <strong>@iris</strong>. (In case you were wondering, Iris is not someone on the team. Iris is the reverse of Siri ğŸ™Š. We love Iris.)</p>

<div class="post-image-section">
  <img alt="Goddess Iris" src="/img/ios-automation/goddess-iris.png" width="50%" />
</div>

<div class="post-image-section">
  <img alt="Iris Slack" src="/img/ios-automation/iris-slack.png" width="50%" />
</div>

<p><code class="language-plaintext highlighter-rouge">Irisbot</code> is a Swift class that conforms to <code class="language-plaintext highlighter-rouge">messageEventsDelegate</code> protocol offered by SlackKit. When it receives a message, we parse the message and enqueue a job into a customised serialised <code class="language-plaintext highlighter-rouge">DispatchQueue</code>. Here are a few lines of the main logic.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">received</span><span class="p">(</span><span class="n">_</span> <span class="nv">message</span><span class="p">:</span> <span class="kt">Message</span><span class="p">,</span> <span class="nv">client</span><span class="p">:</span> <span class="kt">Client</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Interpret message to get the command and sanitize user inputs...</span>

  <span class="c1">// Schedule a job.</span>
  <span class="n">archiveQueue</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
    <span class="c1">// Execute scripts based on command.</span>
    <span class="nf">shell</span><span class="p">(</span><span class="s">"bash"</span><span class="p">,</span> <span class="s">"Scripts/</span><span class="se">\(</span><span class="n">jobType</span><span class="o">.</span><span class="n">executableFileName</span><span class="se">)</span><span class="s">"</span><span class="p">,</span> <span class="n">branch</span><span class="p">)</span>
    <span class="c1">// Notify Slack channel when job is done.</span>
    <span class="n">client</span><span class="o">.</span><span class="n">webAPI</span><span class="o">.</span><span class="nf">sendMessage</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="n">channel</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="s">"job </span><span class="se">\(</span><span class="n">jobID</span><span class="se">)</span><span class="s"> completed"</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="c1">// Send ACK to the channel.</span>
  <span class="n">client</span><span class="o">.</span><span class="n">webAPI</span><span class="o">.</span><span class="nf">sendMessage</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="n">channel</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="s">"building... your job ID is </span><span class="se">\(</span><span class="n">jobID</span><span class="se">)</span><span class="s">"</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now if anyone needs a build they can trigger it themselves. ğŸ‰</p>

<div class="post-image-section">
  <img alt="Corgi Macbook" src="/img/ios-automation/corgi-macbook-meme.jpg" width="80%" />
  <small class="post-image-caption">Literally anyone</small>
</div>

<h3 id="deployments">Deployments</h3>

<p>We sometimes add new features to <strong>@iris</strong> or modify build scripts. How to deploy those changes? We did it with a little help of Capistrano. Here is how:</p>

<p>The plain Iris project looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â”œâ”€â”€ Package.swift
â”œâ”€â”€ Package.pins
â”œâ”€â”€ Packages
â”œâ”€â”€ Sources
â”‚   â””â”€â”€ main.swift
â””â”€â”€ Scripts
</code></pre></div></div>

<p>Additional files after Capistrano look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â”œâ”€â”€ Gemfile
â”œâ”€â”€ Gemfile.lock
â”œâ”€â”€ Capfile
â”œâ”€â”€ config
â”‚   â”œâ”€â”€ deploy
â”‚   â”‚   â””â”€â”€ production.rb
â”‚   â””â”€â”€ deploy.rb
â””â”€â”€ lib
    â””â”€â”€ capistrano
            â””â”€â”€ tasks
</code></pre></div></div>

<p>Iris doesnâ€™t have a staging environment. So simply config the server IPs in <code class="language-plaintext highlighter-rouge">production.rb</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> <span class="s1">'x.x.x.x'</span><span class="p">,</span> <span class="ss">user: </span><span class="s1">'XCode Server User Name'</span>
</code></pre></div></div>

<p>And then a set of variables in <code class="language-plaintext highlighter-rouge">deploy.rb</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:application</span><span class="p">,</span> <span class="s2">"osx-server"</span>
<span class="n">set</span> <span class="ss">:repo_url</span><span class="p">,</span> <span class="s2">"git@github.com:xxx/xxxxx.git"</span>
<span class="n">set</span> <span class="ss">:deploy_to</span><span class="p">,</span> <span class="s2">"/path/to/wherever"</span>
<span class="n">set</span> <span class="ss">:keep_releases</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">ask</span> <span class="ss">:branch</span><span class="p">,</span> <span class="sb">`git rev-parse --abbrev-ref HEAD`</span><span class="p">.</span><span class="nf">chomp</span>
<span class="n">append</span> <span class="ss">:linked_files</span><span class="p">,</span> <span class="s2">"config.json"</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">linked_files</code> will symlink any file in the <code class="language-plaintext highlighter-rouge">shared/</code> folder on the server into the current project directory. Here we linked a <code class="language-plaintext highlighter-rouge">config.json</code> which consists of the path to the iOS passenger app repo on the server and where to put the generated <code class="language-plaintext highlighter-rouge">.xcarchive</code> and <code class="language-plaintext highlighter-rouge">.ipa</code> files. So that people can pass in a different value in their local machine when they want to test out their changes.</p>

<p>We are all set. How simple is that! To deploy ğŸš€, simply execute <code class="language-plaintext highlighter-rouge">cap production deploy</code>.
Screwed up? <code class="language-plaintext highlighter-rouge">cap production deploy:rollback</code> will rescue.</p>

<h3 id="conclusion">Conclusion</h3>

<p>What Grab has now, isnâ€™t the most mature setup (there is still a lot to consider. e.g. scaling, authorisation, better logging etc.), but it serves our needs at the moment. Setting up a basic working environment is not hard at all, it took an engineer slightly over a week. Every team and product has its unique needs and preferences, so do what works for you! We hope this article has given you some insights on some of the decisions made by the iOS team at Grab. We would love to hear about your experience in the comments below.</p>

<p>Happy automating!</p>
:ET